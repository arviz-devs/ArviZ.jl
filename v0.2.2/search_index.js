var documenterSearchIndex = {"docs":
[{"location":"api/#api-1","page":"API","title":"API Overview","text":"","category":"section"},{"location":"api/#plots-api-1","page":"API","title":"Plots","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Name Description\nplot_autocorr Bar plot of the autocorrelation function for a sequence of data.\nplot_compare Summary plot for model comparison.\nplot_density Generate KDE plots for continuous variables and histograms for discrete ones.\nplot_dist Plot distribution as histogram or kernel density estimates.\nplot_elpd Plot a scatter or hexbin matrix of the sampled parameters.\nplot_energy Plot energy transition distribution and marginal energy distribution in HMC algorithms.\nplot_ess Plot quantile, local or evolution of effective sample sizes (ESS).\nplot_forest Forest plot to compare credible intervals from a number of distributions.\nplot_hpd Plot hpd intervals for regression data.\nplot_joint Plot a scatter or hexbin of two variables with their respective marginals distributions.\nplot_kde 1D or 2D KDE plot taking into account boundary conditions.\nplot_khat Plot Pareto tail indices.\nplot_loo_pit Plot Leave-One-Out (LOO) probability integral transformation (PIT) predictive checks.\nplot_mcse Plot quantile, local or evolution of effective sample sizes (ESS).\nplot_pair Plot a scatter or hexbin matrix of the sampled parameters.\nplot_parallel Plot parallel coordinates plot showing posterior points with and without divergences.\nplot_posterior Plot Posterior densities in the style of John K.\nplot_ppc Plot for posterior predictive checks.\nplot_rank Plot rank order statistics of chains.\nplot_trace Plot distribution (histogram or kernel density estimates) and sampled values.\nplot_violin Plot posterior of traces as violin plot.","category":"page"},{"location":"api/#stats-api-1","page":"API","title":"Stats","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Name Description\nsummarystats Compute summary statistics on an InferenceData\nhpd Calculate highest posterior density (HPD) of array for given credible_interval.\nloo Pareto-smoothed importance sampling leave-one-out (LOO) cross-validation.\nloo_pit Compute leave-one-out probability integral transform (PIT) values.\npsislw Pareto smoothed importance sampling (PSIS).\nr2_score R^2 for Bayesian regression models.\nwaic Calculate the widely available information criterion (WAIC).\ncompare Compare models based on WAIC or LOO cross-validation.","category":"page"},{"location":"api/#diagnostics-api-1","page":"API","title":"Diagnostics","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Name Description\nbfmi Calculate the estimated Bayesian fraction of missing information (BFMI).\ngeweke Compute z-scores for convergence diagnostics.\ness Calculate estimate of the effective sample size (ESS).\nrhat Compute estimate of rank normalized split-hatR for a set of traces.\nmcse Calculate Markov Chain Standard Error statistic (MCSE).","category":"page"},{"location":"api/#statsutils-api-1","page":"API","title":"Stats utils","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Name Description\nautocov Compute autocovariance estimates for every lag for the input array.\nautocorr Compute autocorrelation using FFT for every lag for the input array.\nmake_ufunc Make ufunc from a function taking 1D array input.\nwrap_xarray_ufunc Wrap make_ufunc with xarray.apply_ufunc.","category":"page"},{"location":"api/#data-api-1","page":"API","title":"Data","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Name Description\nInferenceData Container for inference data storage using xarray.\nconvert_to_inference_data Convert a supported object to an InferenceData.\nload_arviz_data Load a local or remote pre-made dataset.\nto_netcdf Save dataset as a netcdf file.\nfrom_netcdf Load netcdf file back into an InferenceData.\nfrom_dict Convert Dict data into an InferenceData.\nfrom_cmdstan Convert CmdStan data into an InferenceData.\nfrom_mcmcchains Convert MCMCChains data into an InferenceData.\nconcat Concatenate InferenceData objects.\nconcat! Concatenate InferenceData objects in-place.","category":"page"},{"location":"api/#utils-api-1","page":"API","title":"Utils","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Name Description\nwith_interactive_backend Change plotting backend temporarily.","category":"page"},{"location":"api/#rcparams-api-1","page":"API","title":"rcParams","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Name Description\nwith_rc_context Change ArviZ's matplotlib-style rc settings temporarily.","category":"page"},{"location":"quickstart/#quickstart-1","page":"Quickstart","title":"ArviZ.jl Quickstart","text":"","category":"section"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"This quickstart is adapted from ArviZ's Quickstart.","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"using PyPlot, ArviZ, Distributions, CmdStan, Pkg, InteractiveUtils\n\nusing PyCall\nnp = pyimport_conda(\"numpy\", \"numpy\")\nnp.seterr(divide=\"ignore\", invalid=\"ignore\")\n\nusing Random\nRandom.seed!(42)\n\nturing_chns = read(\"../src/assets/turing_centered_eight_chains.jls\", MCMCChains.Chains)\n\n# use fancy HTML for xarray.Dataset if available\ntry\n    ArviZ.xarray.set_options(display_style = \"html\")\ncatch\n    nothing\nend","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"using ArviZ\n\n# ArviZ ships with style sheets!\nArviZ.use_style(\"arviz-darkgrid\")","category":"page"},{"location":"quickstart/#Get-started-with-plotting-1","page":"Quickstart","title":"Get started with plotting","text":"","category":"section"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"ArviZ.jl is designed to be used with libraries like CmdStan and Turing but works fine with raw arrays.","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"plot_posterior(randn(100_000));\nsavefig(\"quick_postarray.svg\"); nothing # hide","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"(Image: )","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"Plotting a dictionary of arrays, ArviZ.jl will interpret each key as the name of a different random variable. Each row of an array is treated as an independent series of draws from the variable, called a chain. Below, we have 10 chains of 50 draws each for four different distributions.","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"using Distributions\n\nsize = (10, 50)\nplot_forest(Dict(\n    \"normal\" => randn(size),\n    \"gumbel\" => rand(Gumbel(), size),\n    \"student t\" => rand(TDist(6), size),\n    \"exponential\" => rand(Exponential(), size)\n));\nsavefig(\"quick_forestdists.svg\"); nothing # hide","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"(Image: )","category":"page"},{"location":"quickstart/#Plotting-with-MCMCChains.jl's-Chains-objects-produced-by-Turing.jl-1","page":"Quickstart","title":"Plotting with MCMCChains.jl's Chains objects produced by Turing.jl","text":"","category":"section"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"ArviZ is designed to work well with high dimensional, labelled data. Consider the eight schools model, which roughly tries to measure the effectiveness of SAT classes at eight different schools. To show off ArviZ's labelling, I give the schools the names of a different eight schools.","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"This model is small enough to write down, is hierarchical, and uses labelling. Additionally, a centered parameterization causes divergences (which are interesting for illustration).","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"First we create our data.","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"J = 8\ny = [28.0, 8.0, -3.0, 7.0, -1.0, 1.0, 18.0, 12.0]\nsigma = [15.0, 10.0, 16.0, 11.0, 9.0, 11.0, 10.0, 18.0]\nschools = [\n    \"Choate\",\n    \"Deerfield\",\n    \"Phillips Andover\",\n    \"Phillips Exeter\",\n    \"Hotchkiss\",\n    \"Lawrenceville\",\n    \"St. Paul's\",\n    \"Mt. Hermon\"\n];\nnothing # hide","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"Now we write and run the model using Turing:","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"using Turing\n\n@model centered_eight(J, y, sigma) = begin\n    mu ~ Normal(0, 5)\n    tau ~ Truncated(Cauchy(0, 5), 0, Inf)\n    theta = tzeros(J)\n    theta ~ [Normal(mu, tau)]\n    y ~ MvNormal(theta, sigma)\nend\n\nnchains = 4\nmodel = centered_eight(J, y, sigma)\nsampler = NUTS(1000, 0.8)\nturing_chns = mapreduce(chainscat, 1:nchains) do _\n    return sample(model, sampler, 2000; progress = false)\nend;","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"Most ArviZ functions work fine with Chains objects from Turing:","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"plot_autocorr(convert_to_inference_data(turing_chns); var_names=[\"mu\", \"tau\"]);\nsavefig(\"quick_turingautocorr.svg\"); nothing # hide","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"(Image: )","category":"page"},{"location":"quickstart/#Convert-to-InferenceData-1","page":"Quickstart","title":"Convert to InferenceData","text":"","category":"section"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"For much more powerful querying, analysis and plotting, we can use built-in ArviZ utilities to convert Chains objects to xarray datasets. Note we are also giving some information about labelling.","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"ArviZ is built to work with InferenceData (a netcdf datastore that loads data into xarray datasets), and the more groups it has access to, the more powerful analyses it can perform.","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"data = from_mcmcchains(\n    turing_chns,\n#     prior = prior, # hide\n#     posterior_predictive = posterior_predictive, # hide\n    library = \"Turing\",\n    coords = Dict(\"school\" => schools),\n    dims = Dict(\"theta\" => [\"school\"], \"obs\" => [\"school\"])\n)","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"Each group is an ArviZ.Dataset (a thinly wrapped xarray.Dataset). We can view a summary of the dataset.","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"data.posterior","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"Here is a plot of the trace. Note the intelligent labels.","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"plot_trace(data);\nsavefig(\"quick_turingtrace.png\"); nothing # hide","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"(Image: )","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"We can also generate summary stats","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"summarystats(data)","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"and examine the energy distribution of the Hamiltonian sampler","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"plot_energy(data);\nsavefig(\"quick_turingenergy.svg\"); nothing # hide","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"(Image: )","category":"page"},{"location":"quickstart/#Plotting-with-CmdStan.jl-outputs-1","page":"Quickstart","title":"Plotting with CmdStan.jl outputs","text":"","category":"section"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"CmdStan.jl and StanSample.jl also default to producing Chains outputs, and we can easily plot these chains.","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"Here is the same centered eight schools model:","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"using CmdStan\n\nschools_code = \"\"\"\ndata {\n  int<lower=0> J;\n  real y[J];\n  real<lower=0> sigma[J];\n}\n\nparameters {\n  real mu;\n  real<lower=0> tau;\n  real theta[J];\n}\n\nmodel {\n  mu ~ normal(0, 5);\n  tau ~ cauchy(0, 5);\n  theta ~ normal(mu, tau);\n  y ~ normal(theta, sigma);\n}\n\ngenerated quantities {\n    vector[J] log_lik;\n    vector[J] y_hat;\n    for (j in 1:J) {\n        log_lik[j] = normal_lpdf(y[j] | theta[j], sigma[j]);\n        y_hat[j] = normal_rng(theta[j], sigma[j]);\n    }\n}\n\"\"\"\n\nschools_dat = Dict(\"J\" => J, \"y\" => y, \"sigma\" => sigma)\nstan_model = Stanmodel(\n    model = schools_code,\n    nchains = 4,\n    num_warmup = 1000,\n    num_samples = 1000,\n    random = CmdStan.Random(8675309) # hide\n)\n_, stan_chns, _ = stan(stan_model, schools_dat, summary = false);\nnothing # hide","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"plot_density(convert_to_inference_data(stan_chns); var_names=[\"mu\", \"tau\"]);\nsavefig(\"quick_cmdstandensity.svg\"); nothing # hide","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"(Image: )","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"Again, converting to InferenceData, we can get much richer labelling and mixing of data. Note that we're using the same from_cmdstan function used by ArviZ to process cmdstan output files, but through the power of dispatch in Julia, if we pass a Chains object, it instead uses ArviZ.jl's overloads, which forward to from_mcmcchains.","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"data = from_cmdstan(\n    stan_chns;\n    posterior_predictive = \"y_hat\",\n    observed_data = Dict(\"y\" => schools_dat[\"y\"]),\n    log_likelihood = \"log_lik\",\n    coords = Dict(\"school\" => schools),\n    dims = Dict(\n        \"theta\" => [\"school\"],\n        \"y\" => [\"school\"],\n        \"log_lik\" => [\"school\"],\n        \"y_hat\" => [\"school\"],\n        \"theta_tilde\" => [\"school\"]\n    )\n)","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"Here is a plot showing where the Hamiltonian sampler had divergences:","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"plot_pair(data; coords = Dict(\"school\" => [\"Choate\", \"Deerfield\", \"Phillips Andover\"]), divergences = true);\nsavefig(\"quick_cmdstanpair.png\"); nothing # hide","category":"page"},{"location":"quickstart/#","page":"Quickstart","title":"Quickstart","text":"(Image: )","category":"page"},{"location":"reference/#reference-1","page":"Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Modules = [ArviZ]","category":"page"},{"location":"reference/#ArviZ.InferenceData","page":"Reference","title":"ArviZ.InferenceData","text":"InferenceData(::PyObject)\nInferenceData(; kwargs...)\n\nLoose wrapper around arviz.InferenceData, which is a container for inference data storage using xarray.\n\nInferenceData can be constructed either from an arviz.InferenceData or from multiple Datasets assigned to groups specified as kwargs.\n\nInstead of directly creating an InferenceData, use the exported from_xyz functions or convert_to_inference_data.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ArviZ.autocorr-Tuple","page":"Reference","title":"ArviZ.autocorr","text":"See documentation for arviz.autocorr.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.autocov-Tuple","page":"Reference","title":"ArviZ.autocov","text":"See documentation for arviz.autocov.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.bfmi-Tuple","page":"Reference","title":"ArviZ.bfmi","text":"See documentation for arviz.bfmi.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.compare-Tuple","page":"Reference","title":"ArviZ.compare","text":"See documentation for arviz.compare.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.concat!-Tuple{InferenceData,Vararg{InferenceData,N} where N}","page":"Reference","title":"ArviZ.concat!","text":"concat!(data1::InferenceData, data::InferenceData...; kwargs...) -> InferenceData\n\nIn-place version of concat, where data1 is modified to contain the concatenation of data and args. See concat for a description of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.concat-Tuple{Vararg{InferenceData,N} where N}","page":"Reference","title":"ArviZ.concat","text":"See documentation for arviz.concat.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.convert_to_inference_data-Tuple","page":"Reference","title":"ArviZ.convert_to_inference_data","text":"See documentation for arviz.convert_to_inference_data.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.convert_to_inference_data-Tuple{MCMCChains.AbstractChains}","page":"Reference","title":"ArviZ.convert_to_inference_data","text":"convert_to_inference_data(obj::AbstractChains; group = :posterior, kwargs...) -> InferenceData\n\nConvert the chains obj to an InferenceData with the specified group. Remaining kwargs are forwarded to from_mcmcchains.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.ess-Tuple","page":"Reference","title":"ArviZ.ess","text":"See documentation for arviz.ess.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.from_cmdstan-Tuple","page":"Reference","title":"ArviZ.from_cmdstan","text":"See documentation for arviz.from_cmdstan.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.from_cmdstan-Tuple{MCMCChains.AbstractChains}","page":"Reference","title":"ArviZ.from_cmdstan","text":"from_cmdstan(posterior::AbstractChains; kwargs...) -> InferenceData\n\nCall from_mcmcchains on output of CmdStan.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.from_dict-Tuple","page":"Reference","title":"ArviZ.from_dict","text":"See documentation for arviz.from_dict.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.from_mcmcchains-Tuple{Any,Any,Any}","page":"Reference","title":"ArviZ.from_mcmcchains","text":"from_mcmcchains(posterior::AbstractChains; kwargs...) -> InferenceData\nfrom_mcmcchains(; kwargs...) -> InferenceData\nfrom_mcmcchains(\n    posterior::AbstractChains,\n    posterior_predictive::Any,\n    log_likelihood::String;\n    kwargs...\n) -> InferenceData\n\nConvert data in an MCMCChains.AbstractChains format into an InferenceData.\n\nAny keyword argument below without an an explicitly annotated type above is allowed, so long as it can be passed to convert_to_inference_data.\n\nArguments\n\nposterior::AbstractChains: Draws from the posterior\n\nKeywords\n\nposterior_predictive::Any=nothing: Draws from the posterior predictive    distribution or name(s) of predictive variables in posterior\nprior::Any=nothing: Draws from the prior\nprior_predictive::Any=nothing: Draws from the prior predictive distribution    or name(s) of predictive variables in prior\nobserved_data::Dict{String,Array}=nothing: Observed data on which the    posterior is conditional. It should only contain data which is modeled as    a random variable. Keys are parameter names and values.\nconstant_data::Dict{String,Array}=nothing: Model constants, data included    in the model which is not modeled as a random variable. Keys are parameter    names and values.\nlog_likelihood::String=nothing: Name of variable in posterior with log    likelihoods\nlibrary=MCMCChains: Name of library that generated the chains\ncoords::Dict{String,Vector}=nothing: Map from named dimension to named    indices\ndims::Dict{String,Vector{String}}=nothing: Map from variable name to names    of its dimensions\n\nReturns\n\nInferenceData: The data with groups corresponding to the provided data\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.from_netcdf-Tuple","page":"Reference","title":"ArviZ.from_netcdf","text":"See documentation for arviz.from_netcdf.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.geweke-Tuple","page":"Reference","title":"ArviZ.geweke","text":"See documentation for arviz.geweke.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.hpd-Tuple","page":"Reference","title":"ArviZ.hpd","text":"See documentation for arviz.hpd.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.load_arviz_data-Tuple","page":"Reference","title":"ArviZ.load_arviz_data","text":"See documentation for arviz.load_arviz_data.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.loo-Tuple","page":"Reference","title":"ArviZ.loo","text":"See documentation for arviz.loo.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.loo_pit-Tuple","page":"Reference","title":"ArviZ.loo_pit","text":"See documentation for arviz.loo_pit.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.make_ufunc-Tuple","page":"Reference","title":"ArviZ.make_ufunc","text":"See documentation for arviz.make_ufunc.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.mcse-Tuple","page":"Reference","title":"ArviZ.mcse","text":"See documentation for arviz.mcse.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.plot_autocorr-Tuple","page":"Reference","title":"ArviZ.plot_autocorr","text":"See documentation for arviz.plot_autocorr.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.plot_compare-Tuple","page":"Reference","title":"ArviZ.plot_compare","text":"See documentation for arviz.plot_compare.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.plot_density-Tuple","page":"Reference","title":"ArviZ.plot_density","text":"See documentation for arviz.plot_density.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.plot_dist-Tuple","page":"Reference","title":"ArviZ.plot_dist","text":"See documentation for arviz.plot_dist.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.plot_elpd-Tuple","page":"Reference","title":"ArviZ.plot_elpd","text":"See documentation for arviz.plot_elpd.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.plot_energy-Tuple","page":"Reference","title":"ArviZ.plot_energy","text":"See documentation for arviz.plot_energy.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.plot_ess-Tuple","page":"Reference","title":"ArviZ.plot_ess","text":"See documentation for arviz.plot_ess.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.plot_forest-Tuple","page":"Reference","title":"ArviZ.plot_forest","text":"See documentation for arviz.plot_forest.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.plot_hpd-Tuple","page":"Reference","title":"ArviZ.plot_hpd","text":"See documentation for arviz.plot_hpd.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.plot_joint-Tuple","page":"Reference","title":"ArviZ.plot_joint","text":"See documentation for arviz.plot_joint.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.plot_kde-Tuple","page":"Reference","title":"ArviZ.plot_kde","text":"See documentation for arviz.plot_kde.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.plot_khat-Tuple","page":"Reference","title":"ArviZ.plot_khat","text":"See documentation for arviz.plot_khat.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.plot_loo_pit-Tuple","page":"Reference","title":"ArviZ.plot_loo_pit","text":"See documentation for arviz.plot_loo_pit.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.plot_mcse-Tuple","page":"Reference","title":"ArviZ.plot_mcse","text":"See documentation for arviz.plot_mcse.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.plot_pair-Tuple","page":"Reference","title":"ArviZ.plot_pair","text":"See documentation for arviz.plot_pair.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.plot_parallel-Tuple","page":"Reference","title":"ArviZ.plot_parallel","text":"See documentation for arviz.plot_parallel.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.plot_posterior-Tuple","page":"Reference","title":"ArviZ.plot_posterior","text":"See documentation for arviz.plot_posterior.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.plot_ppc-Tuple","page":"Reference","title":"ArviZ.plot_ppc","text":"See documentation for arviz.plot_ppc.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.plot_rank-Tuple","page":"Reference","title":"ArviZ.plot_rank","text":"See documentation for arviz.plot_rank.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.plot_trace-Tuple","page":"Reference","title":"ArviZ.plot_trace","text":"See documentation for arviz.plot_trace.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.plot_violin-Tuple","page":"Reference","title":"ArviZ.plot_violin","text":"See documentation for arviz.plot_violin.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.psislw-Tuple","page":"Reference","title":"ArviZ.psislw","text":"See documentation for arviz.psislw.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.r2_score-Tuple","page":"Reference","title":"ArviZ.r2_score","text":"See documentation for arviz.r2_score.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.rhat-Tuple","page":"Reference","title":"ArviZ.rhat","text":"See documentation for arviz.rhat.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.to_netcdf-Tuple","page":"Reference","title":"ArviZ.to_netcdf","text":"See documentation for arviz.to_netcdf.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.waic-Tuple","page":"Reference","title":"ArviZ.waic","text":"See documentation for arviz.waic.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.with_interactive_backend-Tuple{Any}","page":"Reference","title":"ArviZ.with_interactive_backend","text":"with_interactive_backend(f; backend::Symbol = nothing)\n\nExecute the thunk f in a temporary interactive context with the chosen backend, or provide no arguments to use a default.\n\nExample\n\nidata = load_arviz_data(\"centered_eight\")\nplot_posterior(idata) # inline\nwith_interactive_backend() do\n    plot_density(idata) # interactive\nend\nplot_trace(idata) # inline\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.with_rc_context-Tuple{Any}","page":"Reference","title":"ArviZ.with_rc_context","text":"with_rc_context(f; rc = nothing, fname = nothing)\n\nExecute the thunk f within a context controlled by rc params. To see supported params, execute rc_params().\n\nThis allows one to do:\n\nwith_rc_context(fname = \"pystan.rc\") do\n    idata = load_arviz_data(\"radon\")\n    plot_posterior(idata; var_names=[\"gamma\"])\nend\n\nThe plot would have settings from pystan.rc.\n\nA dictionary can also be passed to the context manager:\n\nwith_rc_context(rc = Dict(\"plot.max_subplots\" => 1), fname = \"pystan.rc\") do\n    idata = load_arviz_data(\"radon\")\n    plot_posterior(idata, var_names=[\"gamma\"])\nend\n\nThe rc dictionary takes precedence over the settings loaded from fname. Passing a dictionary only is also valid.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.wrap_xarray_ufunc-Tuple","page":"Reference","title":"ArviZ.wrap_xarray_ufunc","text":"See documentation for arviz.wrap_xarray_ufunc.\n\n\n\n\n\n","category":"method"},{"location":"reference/#StatsBase.summarystats-Tuple{ArviZ.Dataset}","page":"Reference","title":"StatsBase.summarystats","text":"summarystats(data::Dataset; kwargs...) -> Union{Pandas.DataFrame,Dataset}\nsummarystats(data::InferenceData; group = :posterior kwargs...) -> Union{Pandas.DataFrame,Dataset}\n\nCompute summary statistics on data.\n\nArguments\n\ndata::Union{Dataset,InferenceData}: The data on which to compute summary     statistics. If data is an InferenceData, only the dataset     corresponding to group is used.\n\nKeywords\n\nvar_names::Vector{String}=nothing: Names of variables to include in summary\ninclude_circ::Bool=false: Whether to include circular statistics\nfmt::String=\"wide\": Return format is either Pandas.DataFrame (\"wide\", \"long\")     or Dataset (\"xarray\").\nround_to::Int=nothing: Number of decimals used to round results.     Use nothing to return raw numbers.\nstat_funcs::Union{Dict{String,Function},Vector{Function}}=nothing:     A vector of functions or a dict of functions with function names as keys     used to calculate statistics. By default, the mean, standard deviation,     simulation standard error, and highest posterior density intervals are     included.     The functions will be given one argument, the samples for a variable as an     array, The functions should operate on an array, returning a single     number. For example, Statistics.mean, or Statistics.var would both     work.\nextend::Bool=true: If true, use the statistics returned by stat_funcs in     addition to, rather than in place of, the default statistics. This is only     meaningful when stat_funcs is not nothing.\ncredible_interval::Real=0.94: Credible interval to plot. This is only     meaningful when stat_funcs is nothing.\norder::String=\"C\": If fmt is \"wide\", use either \"C\" or \"F\" unpacking order.\nindex_origin::Int=1: If fmt is \"wide\", select 𝑛-based indexing for     multivariate parameters.\n\nReturns\n\nUnion{Pandas.DataFrame,Dataset}: Return type dicated by fmt argument.     Return value will contain summary statistics for each variable. Default     statistics are:\nmean\nsd\nhpd_3%\nhpd_97%\nmcse_mean\nmcse_sd\ness_bulk\ness_tail\nr_hat (only computed for traces with 2 or more chains)\n\nExamples\n\nusing ArviZ\nidata = load_arviz_data(\"centered_eight\")\nsummarystats(idata; var_names=[\"mu\", \"tau\"])\n\nOther statistics can be calculated by passing a list of functions or a dictionary with key, function pairs:\n\nusing StatsBase, Statistics\nfunction median_sd(x)\n    med = median(x)\n    sd = sqrt(mean((x .- med).^2))\n    return sd\nend\n\nfunc_dict = Dict(\n    \"std\" => x -> std(x; corrected = false),\n    \"median_std\" => median_sd,\n    \"5%\" => x -> percentile(x, 5),\n    \"median\" => median,\n    \"95%\" => x -> percentile(x, 95),\n)\n\nsummarystats(idata; var_names = [\"mu\", \"tau\"], stat_funcs = func_dict, extend = false)\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.Dataset","page":"Reference","title":"ArviZ.Dataset","text":"Dataset(::PyObject)\nDataset(; data_vars = nothing, coords = nothing, attrs = nothing)\n\nLoose wrapper around xarray.Dataset, mostly used for dispatch.\n\nKeywords\n\ndata_vars::Dict{String,Any}: Dict mapping variable names to\nVector: Data vector. Single dimension is named after variable.\nTuple{String,Vector}: Dimension name and data vector.\nTuple{NTuple{N,String},Array{T,N}} where {N,T}: Dimension names and   data array.\ncoords::Dict{String,Any}: Dict mapping dimension names to index names.   Possible arguments has same form as data_vars.\nattrs::Dict{String,Any}: Global attributes to save on this dataset.\n\nIn most cases, use convert_to_dataset or convert_to_constant_dataset or  to create a Dataset instead of directly using a constructor.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ArviZ.convert_to_constant_dataset-Tuple{Dict}","page":"Reference","title":"ArviZ.convert_to_constant_dataset","text":"convert_to_constant_dataset(obj::Dict; kwargs...) -> Dataset\n\nConvert obj into a Dataset. Unlike convert_to_dataset, this is intended for containing constant parameters such as observed data and constant data, and the first two dimensions are not required to be the number of chains and draws.\n\nKeywords\n\ncoords::Dict{String,Vector}: Map from named dimension to index names\ndims::Dict{String,Vector{String}}: Map from variable name to names    of its dimensions\nlibrary::Any: A library associated with the data to add to attrs.\nattrs::Dict{String,Any}: Global attributes to save on this dataset.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.convert_to_dataset-Tuple{Any}","page":"Reference","title":"ArviZ.convert_to_dataset","text":"convert_to_dataset(obj; group = :posterior, kwargs...) -> Dataset\n\nConvert a supported object to a Dataset. In most cases, this function calls convert_to_inference_data and returns the corresponding group.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.dataset_to_dict-Tuple{ArviZ.Dataset}","page":"Reference","title":"ArviZ.dataset_to_dict","text":"dataset_to_dict(ds::Dataset) -> Tuple{Dict{String,Array},NamedTuple}\n\nConvert a Dataset to a dictionary of Arrays. The function also returns keyword arguments to dict_to_dataset.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.dict_to_dataset-Tuple{Any}","page":"Reference","title":"ArviZ.dict_to_dataset","text":"dict_to_dataset(data::Dict{String,Array}; kwargs...) -> Dataset\n\nConvert a dictionary with data and keys as variable names to a Dataset.\n\nKeywords\n\nattrs::Dict{String,Any}: Json serializable metadata to attach to the   dataset, in addition to defaults.\nlibrary::String: Name of library used for performing inference. Will be   attached to the attrs metadata.\ncoords::Dict{String,Array}: Coordinates for the dataset\ndims::Dict{String,Vector{String}}: Dimensions of each variable. The keys   are variable names, values are vectors of coordinates.\n\nExamples\n\nusing ArviZ\nArviZ.dict_to_dataset(Dict(\"x\" => randn(4, 100), \"y\" => randn(4, 100)))\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.from_cmdstanpy-Tuple","page":"Reference","title":"ArviZ.from_cmdstanpy","text":"See documentation for arviz.from_cmdstanpy.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.from_emcee-Tuple","page":"Reference","title":"ArviZ.from_emcee","text":"See documentation for arviz.from_emcee.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.from_numpyro-Tuple","page":"Reference","title":"ArviZ.from_numpyro","text":"See documentation for arviz.from_numpyro.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.from_pymc3-Tuple","page":"Reference","title":"ArviZ.from_pymc3","text":"See documentation for arviz.from_pymc3.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.from_pyro-Tuple","page":"Reference","title":"ArviZ.from_pyro","text":"See documentation for arviz.from_pyro.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.from_pystan-Tuple","page":"Reference","title":"ArviZ.from_pystan","text":"See documentation for arviz.from_pystan.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.from_tfp-Tuple","page":"Reference","title":"ArviZ.from_tfp","text":"See documentation for arviz.from_tfp.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.groupnames-Tuple{InferenceData}","page":"Reference","title":"ArviZ.groupnames","text":"groupnames(data::InferenceData) -> Vector{Symbol}\n\nGet the names of the groups (datasets) in data.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.groups-Tuple{InferenceData}","page":"Reference","title":"ArviZ.groups","text":"groups(data::InferenceData) -> Dict{Symbol,Dataset}\n\nGet the groups in data as a dictionary mapping names to datasets.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.rc_params-Tuple{}","page":"Reference","title":"ArviZ.rc_params","text":"rc_params() > Dict{String,Any}\n\nGet the list of customizable rc params using with_rc_context.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.replacemissing-Tuple{Any}","page":"Reference","title":"ArviZ.replacemissing","text":"replacemissing(x)\n\nReplace missing values with NaN and do type inference on the result.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.reshape_values-Union{Tuple{AbstractArray{T,N}}, Tuple{N}, Tuple{T}} where N where T","page":"Reference","title":"ArviZ.reshape_values","text":"reshape_values(x::AbstractArray) -> AbstractArray\n\nConvert from MCMCChains variable values with dimensions (ndraw, size..., nchain) to ArviZ's expected (nchain, ndraw, size...).\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.styles-Tuple{}","page":"Reference","title":"ArviZ.styles","text":"styles() -> Vector{String}\n\nGet all available matplotlib styles for use with use_style\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.summary-Tuple{Any}","page":"Reference","title":"ArviZ.summary","text":"summary(\n    data;\n    group = :posterior,\n    coords = nothing,\n    dims = nothing,\n    kwargs...,\n) -> Union{Pandas.DataFrame,PyObject}\n\nCompute summary statistics on any object that can be passed to convert_to_dataset.\n\nKeywords\n\ncoords::Dict{String,Vector}=nothing: Map from named dimension to named     indices.\ndims::Dict{String,Vector{String}}=nothing: Map from variable name to names     of its dimensions.\nkwargs: Keyword arguments passed to summarystats.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.use_style-Tuple{Any}","page":"Reference","title":"ArviZ.use_style","text":"use_style(style::String)\nuse_style(style::Vector{String})\n\nUse matplotlib style settings from a style specification style.\n\nThe style name of \"default\" is reserved for reverting back to the default style settings.\n\nArviZ-specific styles are [\"arviz-whitegrid\", \"arviz-darkgrid\", \"arviz-colors\", \"arviz-white\"]. To see all available style specifications, use styles().\n\nIf a Vector of styles is provided, they are applied from first to last.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ArviZ.@forwardfun-Tuple{Any}","page":"Reference","title":"ArviZ.@forwardfun","text":"@forwardfun f\n@forwardfun(f)\n\nWrap a function arviz.f in f, forwarding its docstrings.\n\n\n\n\n\n","category":"macro"},{"location":"#arvizjl-1","page":"Home","title":"ArviZ.jl: Exploratory analysis of Bayesian models in Julia","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"(Image: Build Status) (Image: codecov.io)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"ArviZ.jl is a Julia interface to the ArviZ package for exploratory analysis of Bayesian models.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The reader is urged to consult ArviZ's documentation for detailed description of features and usage. This documentation will be limited to differences between the packages, applications using Julia's probabilistic programming languages (PPLs), and examples in Julia.","category":"page"},{"location":"#purpose-1","page":"Home","title":"Purpose","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Besides removing the need to explicitly import ArviZ with PyCall.jl, ArviZ.jl extends ArviZ with functionality for converting Julia types into ArviZ's InferenceData format. It also allows smoother usage with PyPlot.jl and Pandas.jl and provides functions that can be overloaded by other packages to enable their types to be used with ArviZ.","category":"page"},{"location":"#installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"To use with the default Python environment, first install ArviZ. Then in Julia's REPL run","category":"page"},{"location":"#","page":"Home","title":"Home","text":"] add ArviZ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To install ArviZ.jl with its Python dependencies in Julia's private conda environment, in the console run","category":"page"},{"location":"#","page":"Home","title":"Home","text":"PYTHON=\"\" julia -e 'using Pkg; Pkg.add(\"PyCall\"); Pkg.build(\"PyCall\"); Pkg.add(\"ArviZ\")'","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For specifying other Python versions, see the PyCall documentation.","category":"page"},{"location":"#design-1","page":"Home","title":"Design","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"ArviZ.jl supports all of ArviZ's API, except for its Numba functionality. See ArviZ's API documentation for details.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"ArviZ.jl wraps ArviZ's API functions and closely follows ArviZ's design. It also supports conversion of MCMCChains.jl's Chains as returned by Turing.jl, CmdStan.jl, StanSample.jl, and others into ArviZ's InferenceData format. See Quickstart for examples.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The package is intended to be used with PyPlot.jl.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"ArviZ.jl development occurs on GitHub. Issues and pull requests are welcome.","category":"page"},{"location":"#differences-1","page":"Home","title":"Differences from ArviZ","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"In ArviZ, functions in the API are usually called with the package name prefix, (e.g. arviz.plot_posterior). In ArviZ.jl, most of the same functions are exported and therefore called without the prefix (e.g. plot_posterior). The exception are from_xyz converters for packages that have no (known) Julia wrappers. These functions are not exported to reduce namespace clutter.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For InferenceData inputs, summarystats replaces arviz.summary to avoid confusion with Base.summary. For arbitrary inputs and the full functionality of arviz.summary, use ArviZ.summary, which is not exported.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"ArviZ.jl transparently interconverts between arviz.InferenceData and our own InferenceData, used for dispatch. InferenceData has identical usage to its Python counterpart.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Functions that in ArviZ return Pandas types here return their Pandas.jl wrappers, which are used the same way.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"ArviZ includes the context managers with_rc_context and with_interactive_backend. ArviZ.jl includes functions that can be used with a nearly identical syntax. with_interactive_backend here is not limited to an IPython/IJulia context.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In place of arviz.style.use and arviz.style.styles, ArviZ.jl provides ArviZ.use_style and ArviZ.styles.","category":"page"},{"location":"#extendingarviz-1","page":"Home","title":"Extending ArviZ.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"To use a custom data type with ArviZ.jl, simply overload convert_to_inference_data to convert your input(s) to an InferenceData.","category":"page"},{"location":"#knownissues-1","page":"Home","title":"Known Issues","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"ArviZ.jl uses PyCall.jl to wrap ArviZ. At the moment, Julia segfaults if Numba is imported, which ArviZ does if it is available. For the moment, the workaround is to specify a Python version that doesn't have Numba installed. See this issue for more details.","category":"page"}]
}
