<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Creating custom plots · ArviZ.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="stable/creating_custom_plots/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="ArviZ.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="ArviZ.jl logo"/></a><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../quickstart/">Quickstart</a></li><li><a class="tocitem" href="../working_with_inference_data/">Working with <code>InferenceData</code></a></li><li class="is-active"><a class="tocitem" href>Creating custom plots</a><ul class="internal"><li><a class="tocitem" href="#Environment"><span>Environment</span></a></li></ul></li></ul></li><li><span class="tocitem">Example Gallery</span><ul><li><a class="tocitem" href="../mpl_examples/">Matplotlib</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../api/plots/">Plots</a></li><li><a class="tocitem" href="../api/stats/">Stats</a></li><li><a class="tocitem" href="../api/diagnostics/">Diagnostics</a></li><li><a class="tocitem" href="../api/data/">Data</a></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">InferenceObjects</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../api/inference_data/">InferenceData</a></li><li><a class="tocitem" href="../api/dataset/">Dataset</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Getting Started</a></li><li class="is-active"><a href>Creating custom plots</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Creating custom plots</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/arviz-devs/ArviZ.jl/blob/main/docs/src/creating_custom_plots.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Creating-custom-plots"><a class="docs-heading-anchor" href="#Creating-custom-plots">Creating custom plots</a><a id="Creating-custom-plots-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-custom-plots" title="Permalink"></a></h1><p>While ArviZ includes many plotting functions for visualizing the data stored in <a href="../api/inference_data/#InferenceObjects.InferenceData"><code>InferenceData</code></a> objects, you will often need to construct custom plots, or you may want to tweak some of our plots in your favorite plotting package.</p><p>In this tutorial, we will show you a few useful techniques you can use to construct these plots using Julia’s plotting packages. For demonstration purposes, we’ll use Makie.jl and AlgebraOfGraphics.jl, which can consume <a href="../api/dataset/#InferenceObjects.Dataset"><code>Dataset</code></a> objects since they implement the Tables interface. However, we could just as easily have used StatsPlots.jl.</p><pre><code class="language-julia hljs">using ArviZ, DimensionalData, DataFrames, Statistics, AlgebraOfGraphics, CairoMakie
using AlgebraOfGraphics: density
set_aog_theme!()</code></pre><pre><code class="nohighlight hljs">/home/runner/.julia/conda/3/x86_64/lib/python3.10/site-packages/scipy/__init__.py:146: UserWarning: A NumPy version &gt;=1.17.3 and &lt;1.25.0 is required for this version of SciPy (detected version 1.25.0
  warnings.warn(f&quot;A NumPy version &gt;={np_minversion} and &lt;{np_maxversion}&quot;</code></pre><p>We’ll start by loading some draws from an implementation of the non-centered parameterization of the 8 schools model. In this parameterization, the model has some sampling issues.</p><pre><code class="language-julia hljs">idata = load_example_data(&quot;centered_eight&quot;)</code></pre><div>InferenceData<details>
<summary>posterior</summary>
<pre><code>Dataset with dimensions: 
  Dim{:draw} Sampled{Int64} Int64[0, 1, …, 498, 499] ForwardOrdered Irregular Points,
  Dim{:chain} Sampled{Int64} Int64[0, 1, 2, 3] ForwardOrdered Irregular Points,
  Dim{:school} Categorical{String} String[Choate, Deerfield, …, St. Paul's, Mt. Hermon] Unordered
and 3 layers:
  :mu    Float64 dims: Dim{:draw}, Dim{:chain} (500×4)
  :theta Float64 dims: Dim{:school}, Dim{:draw}, Dim{:chain} (8×500×4)
  :tau   Float64 dims: Dim{:draw}, Dim{:chain} (500×4)
&#10;with metadata Dict{String, Any} with 6 entries:
  "created_at" => "2022-10-13T14:37:37.315398"
  "inference_library_version" => "4.2.2"
  "sampling_time" => 7.48011
  "tuning_steps" => 1000
  "arviz_version" => "0.13.0.dev0"
  "inference_library" => "pymc"</code></pre>
</details>
<details>
<summary>posterior_predictive</summary>
<pre><code>Dataset with dimensions: 
  Dim{:school} Categorical{String} String[Choate, Deerfield, …, St. Paul's, Mt. Hermon] Unordered,
  Dim{:draw} Sampled{Int64} Int64[0, 1, …, 498, 499] ForwardOrdered Irregular Points,
  Dim{:chain} Sampled{Int64} Int64[0, 1, 2, 3] ForwardOrdered Irregular Points
and 1 layer:
  :obs Float64 dims: Dim{:school}, Dim{:draw}, Dim{:chain} (8×500×4)
&#10;with metadata Dict{String, Any} with 4 entries:
  "created_at" => "2022-10-13T14:37:41.460544"
  "inference_library_version" => "4.2.2"
  "arviz_version" => "0.13.0.dev0"
  "inference_library" => "pymc"</code></pre>
</details>
<details>
<summary>log_likelihood</summary>
<pre><code>Dataset with dimensions: 
  Dim{:school} Categorical{String} String[Choate, Deerfield, …, St. Paul's, Mt. Hermon] Unordered,
  Dim{:draw} Sampled{Int64} Int64[0, 1, …, 498, 499] ForwardOrdered Irregular Points,
  Dim{:chain} Sampled{Int64} Int64[0, 1, 2, 3] ForwardOrdered Irregular Points
and 1 layer:
  :obs Float64 dims: Dim{:school}, Dim{:draw}, Dim{:chain} (8×500×4)
&#10;with metadata Dict{String, Any} with 4 entries:
  "created_at" => "2022-10-13T14:37:37.487399"
  "inference_library_version" => "4.2.2"
  "arviz_version" => "0.13.0.dev0"
  "inference_library" => "pymc"</code></pre>
</details>
<details>
<summary>sample_stats</summary>
<pre><code>Dataset with dimensions: 
  Dim{:draw} Sampled{Int64} Int64[0, 1, …, 498, 499] ForwardOrdered Irregular Points,
  Dim{:chain} Sampled{Int64} Int64[0, 1, 2, 3] ForwardOrdered Irregular Points
and 16 layers:
  :max_energy_error    Float64 dims: Dim{:draw}, Dim{:chain} (500×4)
  :energy_error        Float64 dims: Dim{:draw}, Dim{:chain} (500×4)
  :lp                  Float64 dims: Dim{:draw}, Dim{:chain} (500×4)
  :index_in_trajectory Int64 dims: Dim{:draw}, Dim{:chain} (500×4)
  :acceptance_rate     Float64 dims: Dim{:draw}, Dim{:chain} (500×4)
  :diverging           Bool dims: Dim{:draw}, Dim{:chain} (500×4)
  :process_time_diff   Float64 dims: Dim{:draw}, Dim{:chain} (500×4)
  :n_steps             Float64 dims: Dim{:draw}, Dim{:chain} (500×4)
  :perf_counter_start  Float64 dims: Dim{:draw}, Dim{:chain} (500×4)
  :largest_eigval      Union{Missing, Float64} dims: Dim{:draw}, Dim{:chain} (500×4)
  :smallest_eigval     Union{Missing, Float64} dims: Dim{:draw}, Dim{:chain} (500×4)
  :step_size_bar       Float64 dims: Dim{:draw}, Dim{:chain} (500×4)
  :step_size           Float64 dims: Dim{:draw}, Dim{:chain} (500×4)
  :energy              Float64 dims: Dim{:draw}, Dim{:chain} (500×4)
  :tree_depth          Int64 dims: Dim{:draw}, Dim{:chain} (500×4)
  :perf_counter_diff   Float64 dims: Dim{:draw}, Dim{:chain} (500×4)
&#10;with metadata Dict{String, Any} with 6 entries:
  "created_at" => "2022-10-13T14:37:37.324929"
  "inference_library_version" => "4.2.2"
  "sampling_time" => 7.48011
  "tuning_steps" => 1000
  "arviz_version" => "0.13.0.dev0"
  "inference_library" => "pymc"</code></pre>
</details>
<details>
<summary>prior</summary>
<pre><code>Dataset with dimensions: 
  Dim{:draw} Sampled{Int64} Int64[0, 1, …, 498, 499] ForwardOrdered Irregular Points,
  Dim{:chain} Sampled{Int64} Int64[0] ForwardOrdered Irregular Points,
  Dim{:school} Categorical{String} String[Choate, Deerfield, …, St. Paul's, Mt. Hermon] Unordered
and 3 layers:
  :tau   Float64 dims: Dim{:draw}, Dim{:chain} (500×1)
  :theta Float64 dims: Dim{:school}, Dim{:draw}, Dim{:chain} (8×500×1)
  :mu    Float64 dims: Dim{:draw}, Dim{:chain} (500×1)
&#10;with metadata Dict{String, Any} with 4 entries:
  "created_at" => "2022-10-13T14:37:26.602116"
  "inference_library_version" => "4.2.2"
  "arviz_version" => "0.13.0.dev0"
  "inference_library" => "pymc"</code></pre>
</details>
<details>
<summary>prior_predictive</summary>
<pre><code>Dataset with dimensions: 
  Dim{:school} Categorical{String} String[Choate, Deerfield, …, St. Paul's, Mt. Hermon] Unordered,
  Dim{:draw} Sampled{Int64} Int64[0, 1, …, 498, 499] ForwardOrdered Irregular Points,
  Dim{:chain} Sampled{Int64} Int64[0] ForwardOrdered Irregular Points
and 1 layer:
  :obs Float64 dims: Dim{:school}, Dim{:draw}, Dim{:chain} (8×500×1)
&#10;with metadata Dict{String, Any} with 4 entries:
  "created_at" => "2022-10-13T14:37:26.604969"
  "inference_library_version" => "4.2.2"
  "arviz_version" => "0.13.0.dev0"
  "inference_library" => "pymc"</code></pre>
</details>
<details>
<summary>observed_data</summary>
<pre><code>Dataset with dimensions: 
  Dim{:school} Categorical{String} String[Choate, Deerfield, …, St. Paul's, Mt. Hermon] Unordered
and 1 layer:
  :obs Float64 dims: Dim{:school} (8)
&#10;with metadata Dict{String, Any} with 4 entries:
  "created_at" => "2022-10-13T14:37:26.606375"
  "inference_library_version" => "4.2.2"
  "arviz_version" => "0.13.0.dev0"
  "inference_library" => "pymc"</code></pre>
</details>
<details>
<summary>constant_data</summary>
<pre><code>Dataset with dimensions: 
  Dim{:school} Categorical{String} String[Choate, Deerfield, …, St. Paul's, Mt. Hermon] Unordered
and 1 layer:
  :scores Float64 dims: Dim{:school} (8)
&#10;with metadata Dict{String, Any} with 4 entries:
  "created_at" => "2022-10-13T14:37:26.607471"
  "inference_library_version" => "4.2.2"
  "arviz_version" => "0.13.0.dev0"
  "inference_library" => "pymc"</code></pre>
</details>
</div><pre><code class="language-julia hljs">idata.posterior</code></pre><pre><code class="nohighlight hljs">Dataset with dimensions: 
  Dim{:draw} Sampled{Int64} Int64[0, 1, …, 498, 499] ForwardOrdered Irregular Points,
  Dim{:chain} Sampled{Int64} Int64[0, 1, 2, 3] ForwardOrdered Irregular Points,
  Dim{:school} Categorical{String} String[Choate, Deerfield, …, St. Paul&#39;s, Mt. Hermon] Unordered
and 3 layers:
  :mu    Float64 dims: Dim{:draw}, Dim{:chain} (500×4)
  :theta Float64 dims: Dim{:school}, Dim{:draw}, Dim{:chain} (8×500×4)
  :tau   Float64 dims: Dim{:draw}, Dim{:chain} (500×4)

with metadata Dict{String, Any} with 6 entries:
  &quot;created_at&quot;                =&gt; &quot;2022-10-13T14:37:37.315398&quot;
  &quot;inference_library_version&quot; =&gt; &quot;4.2.2&quot;
  &quot;sampling_time&quot;             =&gt; 7.48011
  &quot;tuning_steps&quot;              =&gt; 1000
  &quot;arviz_version&quot;             =&gt; &quot;0.13.0.dev0&quot;
  &quot;inference_library&quot;         =&gt; &quot;pymc&quot;</code></pre><p>The plotting functions we’ll be using interact with a tabular view of a <code>Dataset</code>. Let’s see what that view looks like for a <code>Dataset</code>:</p><pre><code class="language-julia hljs">df = DataFrame(idata.posterior)</code></pre><p>The tabular view includes dimensions and variables as columns.</p><p>When variables with different dimensions are flattened into a tabular form, there’s always some duplication of values. As a simple case, note that <code>chain</code>, <code>draw</code>, and <code>school</code> all have repeated values in the above table.</p><p>In this case, <code>theta</code> has the <code>school</code> dimension, but <code>tau</code> doesn’t, so the values of <code>tau</code> will be repeated in the table for each value of <code>school</code>.</p><pre><code class="language-julia hljs">df[df.school .== Ref(&quot;Choate&quot;), :].tau == df[df.school .== Ref(&quot;Deerfield&quot;), :].tau</code></pre><pre><code class="nohighlight hljs">true</code></pre><p>In our first example, this will be important.</p><p>Here, let’s construct a trace plot. Besides <code>idata</code>, all functions and types in the following cell are defined in AlgebraOfGraphics or Makie:</p><ul><li><code>data(...)</code> indicates that the wrapped object implements the Tables interface</li><li><code>mapping</code> indicates how the data should be used. The symbols are all column names in the table, which for us are our variable names and dimensions.</li><li><code>visual</code> specifies how the data should be converted to a plot.</li><li><code>Lines</code> is a plot type defined in Makie.</li><li><code>draw</code> takes this combination and plots it.</li></ul><pre><code class="language-julia hljs">draw(
    data(idata.posterior.mu) *
    mapping(:draw, :mu; color=:chain =&gt; nonnumeric) *
    visual(Lines; alpha=0.8),
)</code></pre><p><img src="../creating_custom_plots_files/figure-commonmark/cell-8-output-1.png" alt/></p><p>Note the line <code>idata.posterior.mu</code>. If we had just used <code>idata.posterior</code>, the plot would have looked more-or-less the same, but there would be artifacts due to <code>mu</code> being copied many times. By selecting <code>mu</code> directly, all other dimensions are discarded, so each value of <code>mu</code> appears in the plot exactly once.</p><p>When examining an MCMC trace plot, we want to see a “fuzzy caterpillar”. Instead we see a few places where the Markov chains froze. We can do the same for <code>theta</code> as well, but it’s more useful here to separate these draws by <code>school</code>.</p><pre><code class="language-julia hljs">draw(
    data(idata.posterior) *
    mapping(:draw, :theta; layout=:school, color=:chain =&gt; nonnumeric) *
    visual(Lines; alpha=0.8),
)</code></pre><p><img src="../creating_custom_plots_files/figure-commonmark/cell-9-output-1.png" alt/></p><p>Suppose we want to compare <code>tau</code> with <code>theta</code> for two different schools. To do so, we use <code>InferenceData</code>s indexing syntax to subset the data.</p><pre><code class="language-julia hljs">draw(
    data(idata[:posterior, school=At([&quot;Choate&quot;, &quot;Deerfield&quot;])]) *
    mapping(:theta, :tau; color=:school) *
    density() *
    visual(Contour; levels=10),
)</code></pre><pre><code class="nohighlight hljs">┌ Warning: (Dim{:school},) dims were not found in object
└ @ DimensionalData.Dimensions ~/.julia/packages/DimensionalData/pS9IE/src/Dimensions/primitives.jl:659
┌ Warning: (Dim{:school},) dims were not found in object
└ @ DimensionalData.Dimensions ~/.julia/packages/DimensionalData/pS9IE/src/Dimensions/primitives.jl:659</code></pre><p><img src="../creating_custom_plots_files/figure-commonmark/cell-10-output-2.png" alt/></p><p>We can also compare the density plots constructed from each chain for different schools.</p><pre><code class="language-julia hljs">draw(
    data(idata.posterior) *
    mapping(:theta; layout=:school, color=:chain =&gt; nonnumeric) *
    density(),
)</code></pre><p><img src="../creating_custom_plots_files/figure-commonmark/cell-11-output-1.png" alt/></p><p>If we want to compare many schools in a single plot, an ECDF plot is more convenient.</p><pre><code class="language-julia hljs">draw(
    data(idata.posterior) * mapping(:theta; color=:school =&gt; nonnumeric) * visual(ECDFPlot);
    axis=(; ylabel=&quot;probability&quot;),
)</code></pre><p><img src="../creating_custom_plots_files/figure-commonmark/cell-12-output-1.png" alt/></p><p>So far we’ve just plotted data from one group, but we often want to combine data from multiple groups in one plot. The simplest way to do this is to create the plot out of multiple layers. Here we use this approach to plot the observations over the posterior predictive distribution.</p><pre><code class="language-julia hljs">draw(
    (data(idata.posterior_predictive) * mapping(:obs; layout=:school) * density()) +
    (data(idata.observed_data) * mapping(:obs, :obs =&gt; zero =&gt; &quot;&quot;; layout=:school)),
)</code></pre><p><img src="../creating_custom_plots_files/figure-commonmark/cell-13-output-1.png" alt/></p><p>Another option is to combine the groups into a single dataset.</p><p>Here we compare the prior and posterior. Since the prior has 1 chain and the posterior has 4 chains, if we were to combine them into a table, the structure would need to be ragged. This is not currently supported.</p><p>We can then either plot the two distributions separately as we did before, or we can compare a single chain from each group. This is what we’ll do here. To concatenate the two groups, we introduce a new named dimension using <code>DimensionalData.Dim</code>.</p><pre><code class="language-julia hljs">draw(
    data(
        cat(
            idata.posterior[chain=[1]], idata.prior; dims=Dim{:group}([:posterior, :prior])
        )[:mu],
    ) *
    mapping(:mu; color=:group) *
    histogram(; bins=20) *
    visual(; alpha=0.8);
    axis=(; ylabel=&quot;probability&quot;),
)</code></pre><p><img src="../creating_custom_plots_files/figure-commonmark/cell-14-output-1.png" alt/></p><p>From the trace plots, we suspected the geometry of this posterior was bad. Let’s highlight divergent transitions. To do so, we merge <code>posterior</code> and <code>samplestats</code>, which can do with <code>merge</code> since they share no common variable names.</p><pre><code class="language-julia hljs">draw(
    data(merge(idata.posterior, idata.sample_stats)) * mapping(
        :theta,
        :tau;
        layout=:school,
        color=:diverging,
        markersize=:diverging =&gt; (d -&gt; d ? 5 : 2),
    ),
)</code></pre><p><img src="../creating_custom_plots_files/figure-commonmark/cell-15-output-1.png" alt/></p><p>When we try building more complex plots, we may need to build new <code>Dataset</code>s from our existing ones.</p><p>One example of this is the corner plot. To build this plot, we need to make a copy of <code>theta</code> with a copy of the <code>school</code> dimension.</p><pre><code class="language-julia hljs">theta = idata.posterior.theta[school=1:4]
theta2 = rebuild(set(theta; school=:school2); name=:theta2)
plot_data = Dataset(theta, theta2, idata.sample_stats.diverging)
draw(
    data(plot_data) * mapping(
        :theta,
        :theta2 =&gt; &quot;theta&quot;;
        col=:school,
        row=:school2,
        color=:diverging,
        markersize=:diverging =&gt; (d -&gt; d ? 3 : 1),
    );
    figure=(; figsize=(5, 5)),
    axis=(; aspect=1),
)</code></pre><p><img src="../creating_custom_plots_files/figure-commonmark/cell-16-output-1.png" alt/></p><h2 id="Environment"><a class="docs-heading-anchor" href="#Environment">Environment</a><a id="Environment-1"></a><a class="docs-heading-anchor-permalink" href="#Environment" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Pkg
Pkg.status()</code></pre><pre><code class="nohighlight hljs">Status `~/work/ArviZ.jl/ArviZ.jl/docs/Project.toml`
  [cbdf2221] AlgebraOfGraphics v0.6.16
  [131c737c] ArviZ v0.9.0-DEV `~/work/ArviZ.jl/ArviZ.jl`
  [13f3f980] CairoMakie v0.10.6
  [992eb4ea] CondaPkg v0.2.18
  [a93c6f00] DataFrames v1.5.0
  [0703355e] DimensionalData v0.24.12
  [31c24e10] Distributions v0.25.98
  [e30172f5] Documenter v0.27.25
⌅ [f6006082] EvoTrees v0.14.11
  [7073ff75] IJulia v1.24.2
  [c7f686f2] MCMCChains v6.0.3
  [be115224] MCMCDiagnosticTools v0.3.4
  [a7f614a8] MLJBase v0.21.11
  [614be32b] MLJIteration v0.5.1
  [438e738f] PyCall v1.96.1
  [d330b81b] PyPlot v2.11.1
  [754583d1] SampleChains v0.5.1
  [c1514b29] StanSample v7.4.1
⌅ [fce5fe82] Turing v0.24.4
  [f43a241f] Downloads v1.6.0
  [37e2e46d] LinearAlgebra
  [10745b16] Statistics v1.9.0
Info Packages marked with ⌅ have new versions available but compatibility constraints restrict them from upgrading. To see why use `status --outdated`</code></pre><pre><code class="language-julia hljs">versioninfo()</code></pre><pre><code class="nohighlight hljs">Julia Version 1.9.2
Commit e4ee485e909 (2023-07-05 09:39 UTC)
Platform Info:
  OS: Linux (x86_64-linux-gnu)
  CPU: 2 × Intel(R) Xeon(R) Platinum 8272CL CPU @ 2.60GHz
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-14.0.6 (ORCJIT, skylake-avx512)
  Threads: 3 on 2 virtual cores
Environment:
  JULIA_CMDSTAN_HOME = /home/runner/work/ArviZ.jl/ArviZ.jl/.cmdstan//cmdstan-2.25.0/
  JULIA_IMAGE_THREADS = 1
  JULIA_NUM_THREADS = 2</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../working_with_inference_data/">« Working with <code>InferenceData</code></a><a class="docs-footer-nextpage" href="../mpl_examples/">Matplotlib »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 6 July 2023 22:46">Thursday 6 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
