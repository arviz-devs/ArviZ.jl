var documenterSearchIndex = {"docs":
[{"location":"api/inference_data/#inferencedata-api","page":"InferenceData","title":"InferenceData","text":"","category":"section"},{"location":"api/inference_data/","page":"InferenceData","title":"InferenceData","text":"Pages = [\"inference_data.md\"]","category":"page"},{"location":"api/inference_data/#Type-definition","page":"InferenceData","title":"Type definition","text":"","category":"section"},{"location":"api/inference_data/#InferenceObjects.InferenceData","page":"InferenceData","title":"InferenceObjects.InferenceData","text":"InferenceData{group_names,group_types}\n\nContainer for inference data storage using DimensionalData.\n\nThis object implements the InferenceData schema.\n\nInternally, groups are stored in a NamedTuple, which can be accessed using parent(::InferenceData).\n\nConstructors\n\nInferenceData(groups::NamedTuple)\nInferenceData(; groups...)\n\nConstruct an inference data from either a NamedTuple or keyword arguments of groups.\n\nGroups must be Dataset objects.\n\nInstead of directly creating an InferenceData, use the exported from_xyz functions or convert_to_inference_data.\n\n\n\n\n\n","category":"type"},{"location":"api/inference_data/#Property-interface","page":"InferenceData","title":"Property interface","text":"","category":"section"},{"location":"api/inference_data/#Base.getproperty","page":"InferenceData","title":"Base.getproperty","text":"getproperty(data::InferenceData, name::Symbol) -> Dataset\n\nGet group with the specified name.\n\n\n\n\n\n","category":"function"},{"location":"api/inference_data/#Base.propertynames","page":"InferenceData","title":"Base.propertynames","text":"propertynames(data::InferenceData) -> Tuple{Symbol}\n\nGet names of groups\n\n\n\n\n\n","category":"function"},{"location":"api/inference_data/#Indexing-interface","page":"InferenceData","title":"Indexing interface","text":"","category":"section"},{"location":"api/inference_data/#Base.getindex","page":"InferenceData","title":"Base.getindex","text":"Base.getindex(data::InferenceData, groups::Symbol; coords...) -> Dataset\nBase.getindex(data::InferenceData, groups; coords...) -> InferenceData\n\nReturn a new InferenceData containing the specified groups sliced to the specified coords.\n\ncoords specifies a dimension name mapping to an index, a DimensionalData.Selector, or an IntervalSets.AbstractInterval.\n\nIf one or more groups lack the specified dimension, a warning is raised but can be ignored. All groups that contain the dimension must also contain the specified indices, or an exception will be raised.\n\nExamples\n\nSelect data from all groups for just the specified id values.\n\njulia> using InferenceObjects, DimensionalData\n\njulia> idata = from_namedtuple(\n           (θ=randn(4, 100, 4), τ=randn(4, 100));\n           prior=(θ=randn(4, 100, 4), τ=randn(4, 100)),\n           observed_data=(y=randn(4),),\n           dims=(θ=[:id], y=[:id]),\n           coords=(id=[\"a\", \"b\", \"c\", \"d\"],),\n       )\nInferenceData with groups:\n  > posterior\n  > prior\n  > observed_data\n\njulia> idata.posterior\nDataset with dimensions:\n  Dim{:chain} Sampled 1:4 ForwardOrdered Regular Points,\n  Dim{:draw} Sampled 1:100 ForwardOrdered Regular Points,\n  Dim{:id} Categorical String[a, b, c, d] ForwardOrdered\nand 2 layers:\n  :θ Float64 dims: Dim{:chain}, Dim{:draw}, Dim{:id} (4×100×4)\n  :τ Float64 dims: Dim{:chain}, Dim{:draw} (4×100)\n\nwith metadata Dict{String, Any} with 1 entry:\n  \"created_at\" => \"2022-08-11T11:15:21.4\"\n\njulia> idata_sel = idata[id=At([\"a\", \"b\"])]\nInferenceData with groups:\n  > posterior\n  > prior\n  > observed_data\n\njulia> idata_sel.posterior\nDataset with dimensions:\n  Dim{:chain} Sampled 1:4 ForwardOrdered Regular Points,\n  Dim{:draw} Sampled 1:100 ForwardOrdered Regular Points,\n  Dim{:id} Categorical String[a, b] ForwardOrdered\nand 2 layers:\n  :θ Float64 dims: Dim{:chain}, Dim{:draw}, Dim{:id} (4×100×2)\n  :τ Float64 dims: Dim{:chain}, Dim{:draw} (4×100)\n\nwith metadata Dict{String, Any} with 1 entry:\n  \"created_at\" => \"2022-08-11T11:15:21.4\"\n\nSelect data from just the posterior, returning a Dataset if the indices index more than one element from any of the variables:\n\njulia> idata[:observed_data, id=At([\"a\"])]\nDataset with dimensions:\n  Dim{:id} Categorical String[a] ForwardOrdered\nand 1 layer:\n  :y Float64 dims: Dim{:id} (1)\n\nwith metadata Dict{String, Any} with 1 entry:\n  \"created_at\" => \"2022-08-11T11:19:25.982\"\n\nNote that if a single index is provided, the behavior is still to slice so that the dimension is preserved.\n\n\n\n\n\n","category":"function"},{"location":"api/inference_data/#Base.setindex","page":"InferenceData","title":"Base.setindex","text":"Base.setindex(data::InferenceData, group::Dataset, name::Symbol) -> InferenceData\n\nCreate a new InferenceData containing the group with the specified name.\n\nIf a group with name is already in data, it is replaced.\n\n\n\n\n\n","category":"function"},{"location":"api/inference_data/#Iteration-interface","page":"InferenceData","title":"Iteration interface","text":"","category":"section"},{"location":"api/inference_data/","page":"InferenceData","title":"InferenceData","text":"InferenceData also implements the same iteration interface as its underlying NamedTuple. That is, iterating over an InferenceData iterates over its groups.","category":"page"},{"location":"api/inference_data/#General-conversion","page":"InferenceData","title":"General conversion","text":"","category":"section"},{"location":"api/inference_data/#InferenceObjects.convert_to_inference_data","page":"InferenceData","title":"InferenceObjects.convert_to_inference_data","text":"convert_to_inference_data(obj; group, kwargs...) -> InferenceData\n\nConvert a supported object to an InferenceData object.\n\nIf obj converts to a single dataset, group specifies which dataset in the resulting InferenceData that is.\n\nSee convert_to_dataset\n\nArguments\n\nobj can be many objects. Basic supported types are:\nInferenceData: return unchanged\nDataset/DimensionalData.AbstractDimStack: add to InferenceData as the only group\nNamedTuple/AbstractDict: create a Dataset as the only group\nAbstractArray{<:Real}: create a Dataset as the only group, given an arbitrary name, if the name is not set\n\nMore specific types may be documented separately.\n\nKeywords\n\ngroup::Symbol = :posterior: If obj converts to a single dataset, assign the resulting dataset to this group.\ndims: a collection mapping variable names to collections of objects containing dimension names. Acceptable such objects are:\nSymbol: dimension name\nType{<:DimensionsionalData.Dimension}: dimension type\nDimensionsionalData.Dimension: dimension, potentially with indices\nNothing: no dimension name provided, dimension name is automatically generated\ncoords: a collection indexable by dimension name specifying the indices of the given dimension. If indices for a dimension in dims are provided, they are used even if the dimension contains its own indices. If a dimension is missing, its indices are automatically generated.\nkwargs: remaining keywords forwarded to converter functions\n\n\n\n\n\n","category":"function"},{"location":"api/inference_data/#InferenceObjects.from_dict","page":"InferenceData","title":"InferenceObjects.from_dict","text":"from_dict(posterior::AbstractDict; kwargs...) -> InferenceData\n\nConvert a dictionary to an InferenceData.\n\nArguments\n\nposterior: The data to be converted. Its strings must be Symbol or AbstractString, and its values must be arrays.\n\nKeywords\n\nposterior_predictive::Any=nothing: Draws from the posterior predictive distribution\nsample_stats::Any=nothing: Statistics of the posterior sampling process\npredictions::Any=nothing: Out-of-sample predictions for the posterior.\nprior::Dict=nothing: Draws from the prior\nprior_predictive::Any=nothing: Draws from the prior predictive distribution\nsample_stats_prior::Any=nothing: Statistics of the prior sampling process\nobserved_data::NamedTuple: Observed data on which the posterior is conditional. It should only contain data which is modeled as a random variable. Keys are parameter names and values.\nconstant_data::NamedTuple: Model constants, data included in the model which is not modeled as a random variable. Keys are parameter names and values.\npredictions_constant_data::NamedTuple: Constants relevant to the model predictions (i.e. new x values in a linear regression).\nlog_likelihood: Pointwise log-likelihood for the data. It is recommended to use this argument as a NamedTuple whose keys are observed variable names and whose values are log likelihood arrays.\nlibrary: Name of library that generated the draws\ncoords: Map from named dimension to named indices\ndims: Map from variable name to names of its dimensions\n\nReturns\n\nInferenceData: The data with groups corresponding to the provided data\n\nExamples\n\nusing InferenceObjects\nnchains = 2\nndraws = 100\n\ndata = Dict(\n    :x => rand(ndraws, nchains),\n    :y => randn(2, ndraws, nchains),\n    :z => randn(3, 2, ndraws, nchains),\n)\nidata = from_dict(data)\n\n\n\n\n\n","category":"function"},{"location":"api/inference_data/#InferenceObjects.from_namedtuple","page":"InferenceData","title":"InferenceObjects.from_namedtuple","text":"from_namedtuple(posterior::NamedTuple; kwargs...) -> InferenceData\nfrom_namedtuple(posterior::Vector{Vector{<:NamedTuple}}; kwargs...) -> InferenceData\nfrom_namedtuple(\n    posterior::NamedTuple,\n    sample_stats::Any,\n    posterior_predictive::Any,\n    predictions::Any,\n    log_likelihood::Any;\n    kwargs...\n) -> InferenceData\n\nConvert a NamedTuple or container of NamedTuples to an InferenceData.\n\nIf containers are passed, they are flattened into a single NamedTuple with array elements whose first dimensions correspond to the dimensions of the containers.\n\nArguments\n\nposterior: The data to be converted. It may be of the following types:\n::NamedTuple: The keys are the variable names and the values are arrays with dimensions (ndraws, nchains[, sizes...]).\n::Vector{Vector{<:NamedTuple}}: A vector of length nchains whose elements have length ndraws.\n\nKeywords\n\nposterior_predictive::Any=nothing: Draws from the posterior predictive distribution\nsample_stats::Any=nothing: Statistics of the posterior sampling process\npredictions::Any=nothing: Out-of-sample predictions for the posterior.\nprior=nothing: Draws from the prior. Accepts the same types as posterior.\nprior_predictive::Any=nothing: Draws from the prior predictive distribution\nsample_stats_prior::Any=nothing: Statistics of the prior sampling process\nobserved_data::NamedTuple: Observed data on which the posterior is conditional. It should only contain data which is modeled as a random variable. Keys are parameter names and values.\nconstant_data::NamedTuple: Model constants, data included in the model which is not modeled as a random variable. Keys are parameter names and values.\npredictions_constant_data::NamedTuple: Constants relevant to the model predictions (i.e. new x values in a linear regression).\nlog_likelihood: Pointwise log-likelihood for the data. It is recommended to use this argument as a NamedTuple whose keys are observed variable names and whose values are log likelihood arrays.\nlibrary: Name of library that generated the draws\ncoords: Map from named dimension to named indices\ndims: Map from variable name to names of its dimensions\n\nReturns\n\nInferenceData: The data with groups corresponding to the provided data\n\nnote: Note\nIf a NamedTuple is provided for observed_data, constant_data, or predictionsconstantdata`, any non-array values (e.g. integers) are converted to 0-dimensional arrays.\n\nExamples\n\nusing InferenceObjects\nnchains = 2\nndraws = 100\n\ndata1 = (\n    x=rand(ndraws, nchains), y=randn(ndraws, nchains, 2), z=randn(ndraws, nchains, 3, 2)\n)\nidata1 = from_namedtuple(data1)\n\ndata2 = [[(x=rand(), y=randn(2), z=randn(3, 2)) for _ in 1:ndraws] for _ in 1:nchains];\nidata2 = from_namedtuple(data2)\n\n\n\n\n\n","category":"function"},{"location":"api/inference_data/#General-functions","page":"InferenceData","title":"General functions","text":"","category":"section"},{"location":"api/inference_data/#Base.cat","page":"InferenceData","title":"Base.cat","text":"cat(data::InferenceData...; [groups=keys(data[1]),] dims) -> InferenceData\n\nConcatenate InferenceData objects along the specified dimension dims.\n\nOnly the groups in groups are concatenated. Remaining groups are merged into the new InferenceData object.\n\nExamples\n\nHere is how we can concatenate all groups of two InferenceData objects along the existing chain dimension:\n\njulia> coords = (; a_dim=[\"x\", \"y\", \"z\"]);\n\njulia> dims = dims=(; a=[:a_dim]);\n\njulia> data = Dict(:a => randn(100, 4, 3), :b => randn(100, 4));\n\njulia> idata = from_dict(data; coords=coords, dims=dims)\nInferenceData with groups:\n  > posterior\n\njulia> idata_cat1 = cat(idata, idata; dims=:chain)\nInferenceData with groups:\n  > posterior\n\njulia> idata_cat1.posterior\n┌ 100×8×3 Dataset ┐\n├─────────────────┴──────────────────────────────────── dims ┐\n  ↓ draw,\n  → chain,\n  ↗ a_dim Categorical{String} [\"x\", …, \"z\"] ForwardOrdered\n├──────────────────────────────────────────────────── layers ┤\n  :a eltype: Float64 dims: draw, chain, a_dim size: 100×8×3\n  :b eltype: Float64 dims: draw, chain size: 100×8\n├────────────────────────────────────────────────── metadata ┤\n  Dict{String, Any} with 1 entry:\n  \"created_at\" => \"2025-07-25T10:11:18.92\"\n\nAlternatively, we can concatenate along a new run dimension, which will be created.\n\njulia> idata_cat2 = cat(idata, idata; dims=:run)\nInferenceData with groups:\n  > posterior\n\njulia> idata_cat2.posterior\n┌ 100×4×3×2 Dataset ┐\n├───────────────────┴───────────────────────────────────────── dims ┐\n  ↓ draw,\n  → chain,\n  ↗ a_dim Categorical{String} [\"x\", …, \"z\"] ForwardOrdered,\n  ⬔ run\n├─────────────────────────────────────────────────────────── layers ┤\n  :a eltype: Float64 dims: draw, chain, a_dim, run size: 100×4×3×2\n  :b eltype: Float64 dims: draw, chain, run size: 100×4×2\n├───────────────────────────────────────────────────────── metadata ┤\n  Dict{String, Any} with 1 entry:\n  \"created_at\" => \"2025-07-25T10:11:18.92\"\n\nWe can also concatenate only a subset of groups and merge the rest, which is useful when some groups are present only in some of the InferenceData objects or will be identical in all of them:\n\njulia> observed_data = Dict(:y => randn(10));\n\njulia> idata2 = from_dict(data; observed_data=observed_data, coords=coords, dims=dims)\nInferenceData with groups:\n  > posterior\n  > observed_data\n\njulia> idata_cat3 = cat(idata, idata2; groups=(:posterior,), dims=:run)\nInferenceData with groups:\n  > posterior\n  > observed_data\n\njulia> idata_cat3.posterior\n┌ 100×4×3×2 Dataset ┐\n├───────────────────┴───────────────────────────────────────── dims ┐\n  ↓ draw,\n  → chain,\n  ↗ a_dim Categorical{String} [\"x\", …, \"z\"] ForwardOrdered,\n  ⬔ run\n├─────────────────────────────────────────────────────────── layers ┤\n  :a eltype: Float64 dims: draw, chain, a_dim, run size: 100×4×3×2\n  :b eltype: Float64 dims: draw, chain, run size: 100×4×2\n├───────────────────────────────────────────────────────── metadata ┤\n  Dict{String, Any} with 1 entry:\n  \"created_at\" => \"2025-07-25T10:11:18.92\"\n\njulia> idata_cat3.observed_data\n┌ 10-element Dataset ┐\n├────────────────────┴───────────────── dims ┐\n  ↓ y_dim_1\n├──────────────────────────────────── layers ┤\n  :y eltype: Float64 dims: y_dim_1 size: 10\n├────────────────────────────────────────────┴ metadata ┐\n  Dict{String, Any} with 1 entry:\n  \"created_at\" => \"2025-07-25T10:11:18.951\"\n\n\n\n\n\n","category":"function"},{"location":"api/inference_data/#Base.merge","page":"InferenceData","title":"Base.merge","text":"merge(data::InferenceData...) -> InferenceData\n\nMerge InferenceData objects.\n\nThe result contains all groups in data and others. If a group appears more than once, the one that occurs last is kept.\n\nSee also: cat\n\nExamples\n\nHere we merge an InferenceData containing only a posterior group with one containing only a prior group to create a new one containing both groups.\n\njulia> idata1 = from_dict(Dict(:a => randn(100, 4, 3), :b => randn(100, 4)))\nInferenceData with groups:\n  > posterior\n\njulia> idata2 = from_dict(; prior=Dict(:a => randn(100, 1, 3), :c => randn(100, 1)))\nInferenceData with groups:\n  > prior\n\njulia> idata_merged = merge(idata1, idata2)\nInferenceData with groups:\n  > posterior\n  > prior\n\n\n\n\n\n","category":"function"},{"location":"quickstart/#ArviZ-Quickstart","page":"Quickstart","title":"ArviZ Quickstart","text":"","category":"section"},{"location":"quickstart/#Set-up","page":"Quickstart","title":"Set-up","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Here we add the necessary packages for this notebook and load a few we will use throughout.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"using ArviZ, ArviZPythonPlots, Distributions, LinearAlgebra, Random, StanSample, Turing","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"    CondaPkg Found dependencies: /home/runner/.julia/packages/DimensionalData/48C1z/CondaPkg.toml\n    CondaPkg Found dependencies: /home/runner/.julia/packages/PythonCall/avYrV/CondaPkg.toml\n    CondaPkg Found dependencies: /home/runner/.julia/packages/ArviZPythonPlots/TzoLB/CondaPkg.toml\n    CondaPkg Found dependencies: /home/runner/.julia/packages/PythonPlot/oS8x4/CondaPkg.toml\n    CondaPkg Resolving changes\n             + arviz\n             + libstdcxx-ng\n             + matplotlib\n             + numpy\n             + openssl\n             + pandas\n             + python\n             + xarray\n    CondaPkg Initialising pixi\n             │ /home/runner/.julia/artifacts/cefba4912c2b400756d043a2563ef77a0088866b/bin/pixi\n             │ init\n             │ --format pixi\n             └ /home/runner/work/ArviZ.jl/ArviZ.jl/docs/.CondaPkg\n✔ Created /home/runner/work/ArviZ.jl/ArviZ.jl/docs/.CondaPkg/pixi.toml\n    CondaPkg Wrote /home/runner/work/ArviZ.jl/ArviZ.jl/docs/.CondaPkg/pixi.toml\n             │ [dependencies]\n             │ openssl = \">=3, <3.6, >=3, <3.6\"\n             │ libstdcxx-ng = \">=3.4,<15.0\"\n             │ matplotlib = \">=1\"\n             │ pandas = \"*\"\n             │ xarray = \"*\"\n             │ arviz = \">=0.15.0,<=0.18\"\n             │ numpy = \"*\"\n             │ \n             │     [dependencies.python]\n             │     channel = \"conda-forge\"\n             │     build = \"*cpython*\"\n             │     version = \">=3.8,<4\"\n             │ \n             │ [project]\n             │ name = \".CondaPkg\"\n             │ platforms = [\"linux-64\"]\n             │ channels = [\"conda-forge\"]\n             │ channel-priority = \"strict\"\n             └ description = \"automatically generated by CondaPkg.jl\"\n    CondaPkg Installing packages\n             │ /home/runner/.julia/artifacts/cefba4912c2b400756d043a2563ef77a0088866b/bin/pixi\n             │ install\n             └ --manifest-path /home/runner/work/ArviZ.jl/ArviZ.jl/docs/.CondaPkg/pixi.toml\n✔ The default environment has been installed.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"# ArviZPythonPlots ships with style sheets!\nuse_style(\"arviz-darkgrid\")","category":"page"},{"location":"quickstart/#Get-started-with-plotting","page":"Quickstart","title":"Get started with plotting","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"To plot with ArviZ, we need to load the ArviZPythonPlots package. ArviZ is designed to be used with libraries like Stan, Turing.jl, and Soss.jl but works fine with raw arrays.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"rng1 = Random.MersenneTwister(37772);","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"plot_posterior(randn(rng1, 100_000));","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Plotting a dictionary of arrays, ArviZ will interpret each key as the name of a different random variable. Each row of an array is treated as an independent series of draws from the variable, called a chain. Below, we have 10 chains of 50 draws each for four different distributions.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"s = (50, 10)\nplot_forest((\n    normal=randn(rng1, s),\n    gumbel=rand(rng1, Gumbel(), s),\n    student_t=rand(rng1, TDist(6), s),\n    exponential=rand(rng1, Exponential(), s),\n));","category":"page"},{"location":"quickstart/#Plotting-with-MCMCChains.jl’s-Chains-objects-produced-by-Turing.jl","page":"Quickstart","title":"Plotting with MCMCChains.jl’s Chains objects produced by Turing.jl","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"ArviZ is designed to work well with high dimensional, labelled data. Consider the eight schools model, which roughly tries to measure the effectiveness of SAT classes at eight different schools. To show off ArviZ’s labelling, I give the schools the names of a different eight schools.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"This model is small enough to write down, is hierarchical, and uses labelling. Additionally, a centered parameterization causes divergences (which are interesting for illustration).","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"First we create our data and set some sampling parameters.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"J = 8\ny = [28.0, 8.0, -3.0, 7.0, -1.0, 1.0, 18.0, 12.0]\nσ = [15.0, 10.0, 16.0, 11.0, 9.0, 11.0, 10.0, 18.0]\nschools = [\n    \"Choate\",\n    \"Deerfield\",\n    \"Phillips Andover\",\n    \"Phillips Exeter\",\n    \"Hotchkiss\",\n    \"Lawrenceville\",\n    \"St. Paul's\",\n    \"Mt. Hermon\",\n]\nndraws = 1_000\nndraws_warmup = 1_000\nnchains = 4;","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Now we write and run the model using Turing:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Turing.@model function model_turing(y, σ, J=length(y))\n    μ ~ Normal(0, 5)\n    τ ~ truncated(Cauchy(0, 5), 0, Inf)\n    θ ~ filldist(Normal(μ, τ), J)\n    for i in 1:J\n        y[i] ~ Normal(θ[i], σ[i])\n    end\nend;","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"rng2 = Random.MersenneTwister(16653);","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"param_mod_turing = model_turing(y, σ)\nsampler = NUTS(ndraws_warmup, 0.8)\n\nturing_chns = Turing.sample(\n    rng2, model_turing(y, σ), sampler, MCMCThreads(), ndraws, nchains\n);","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Sampling (2 threads)   0%|                              |  ETA: N/A\n┌ Info: Found initial step size\n└   ϵ = 0.2\n┌ Info: Found initial step size\n└   ϵ = 0.41250000000000003\nSampling (2 threads)   0%|▏                             |  ETA: 0:47:39\nSampling (2 threads)   1%|▎                             |  ETA: 0:23:44\nSampling (2 threads)   2%|▌                             |  ETA: 0:15:45\nSampling (2 threads)   2%|▋                             |  ETA: 0:11:46\nSampling (2 threads)   2%|▊                             |  ETA: 0:09:23\nSampling (2 threads)   3%|▉                             |  ETA: 0:07:47\nSampling (2 threads)   4%|█                             |  ETA: 0:06:38\nSampling (2 threads)   4%|█▎                            |  ETA: 0:05:47\nSampling (2 threads)   4%|█▍                            |  ETA: 0:05:07\nSampling (2 threads)   5%|█▌                            |  ETA: 0:04:35\nSampling (2 threads)   6%|█▋                            |  ETA: 0:04:09\nSampling (2 threads)   6%|█▊                            |  ETA: 0:03:47\nSampling (2 threads)   6%|██                            |  ETA: 0:03:29\nSampling (2 threads)   7%|██▏                           |  ETA: 0:03:13\nSampling (2 threads)   8%|██▎                           |  ETA: 0:02:59\nSampling (2 threads)   8%|██▍                           |  ETA: 0:02:47\nSampling (2 threads)   8%|██▌                           |  ETA: 0:02:36\nSampling (2 threads)   9%|██▊                           |  ETA: 0:02:27\nSampling (2 threads)  10%|██▉                           |  ETA: 0:02:19\nSampling (2 threads)  10%|███                           |  ETA: 0:02:11\nSampling (2 threads)  10%|███▏                          |  ETA: 0:02:04\nSampling (2 threads)  11%|███▎                          |  ETA: 0:01:58\nSampling (2 threads)  12%|███▌                          |  ETA: 0:01:52\nSampling (2 threads)  12%|███▋                          |  ETA: 0:01:47\nSampling (2 threads)  12%|███▊                          |  ETA: 0:01:42\nSampling (2 threads)  13%|███▉                          |  ETA: 0:01:38\nSampling (2 threads)  14%|████                          |  ETA: 0:01:33\nSampling (2 threads)  14%|████▎                         |  ETA: 0:01:30\nSampling (2 threads)  14%|████▍                         |  ETA: 0:01:26\nSampling (2 threads)  15%|████▌                         |  ETA: 0:01:23\nSampling (2 threads)  16%|████▋                         |  ETA: 0:01:20\nSampling (2 threads)  16%|████▊                         |  ETA: 0:01:17\nSampling (2 threads)  16%|█████                         |  ETA: 0:01:14\nSampling (2 threads)  17%|█████▏                        |  ETA: 0:01:11\nSampling (2 threads)  18%|█████▎                        |  ETA: 0:01:09\nSampling (2 threads)  18%|█████▍                        |  ETA: 0:01:07\nSampling (2 threads)  18%|█████▌                        |  ETA: 0:01:05\nSampling (2 threads)  19%|█████▊                        |  ETA: 0:01:02\nSampling (2 threads)  20%|█████▉                        |  ETA: 0:01:01\nSampling (2 threads)  20%|██████                        |  ETA: 0:00:59\nSampling (2 threads)  20%|██████▏                       |  ETA: 0:00:57\nSampling (2 threads)  21%|██████▎                       |  ETA: 0:00:55\nSampling (2 threads)  22%|██████▌                       |  ETA: 0:00:54\nSampling (2 threads)  22%|██████▋                       |  ETA: 0:00:52\nSampling (2 threads)  22%|██████▊                       |  ETA: 0:00:51\nSampling (2 threads)  23%|██████▉                       |  ETA: 0:00:50\nSampling (2 threads)  24%|███████                       |  ETA: 0:00:48\nSampling (2 threads)  24%|███████▎                      |  ETA: 0:00:47\nSampling (2 threads)  24%|███████▍                      |  ETA: 0:00:46\nSampling (2 threads)  25%|███████▌                      |  ETA: 0:00:44\nSampling (2 threads)  26%|███████▋                      |  ETA: 0:00:43\nSampling (2 threads)  26%|███████▊                      |  ETA: 0:00:42\nSampling (2 threads)  26%|████████                      |  ETA: 0:00:41\nSampling (2 threads)  27%|████████▏                     |  ETA: 0:00:40\nSampling (2 threads)  28%|████████▎                     |  ETA: 0:00:39\nSampling (2 threads)  28%|████████▍                     |  ETA: 0:00:38\nSampling (2 threads)  28%|████████▌                     |  ETA: 0:00:37\nSampling (2 threads)  29%|████████▊                     |  ETA: 0:00:36\nSampling (2 threads)  30%|████████▉                     |  ETA: 0:00:36\nSampling (2 threads)  30%|█████████                     |  ETA: 0:00:35\nSampling (2 threads)  30%|█████████▏                    |  ETA: 0:00:34\nSampling (2 threads)  31%|█████████▎                    |  ETA: 0:00:33\nSampling (2 threads)  32%|█████████▌                    |  ETA: 0:00:32\nSampling (2 threads)  32%|█████████▋                    |  ETA: 0:00:32\nSampling (2 threads)  32%|█████████▊                    |  ETA: 0:00:31\nSampling (2 threads)  33%|█████████▉                    |  ETA: 0:00:30\nSampling (2 threads)  34%|██████████                    |  ETA: 0:00:30\nSampling (2 threads)  34%|██████████▎                   |  ETA: 0:00:29\nSampling (2 threads)  34%|██████████▍                   |  ETA: 0:00:28\nSampling (2 threads)  35%|██████████▌                   |  ETA: 0:00:28\nSampling (2 threads)  36%|██████████▋                   |  ETA: 0:00:27\nSampling (2 threads)  36%|██████████▊                   |  ETA: 0:00:27\nSampling (2 threads)  36%|███████████                   |  ETA: 0:00:26\nSampling (2 threads)  37%|███████████▏                  |  ETA: 0:00:26\nSampling (2 threads)  38%|███████████▎                  |  ETA: 0:00:25\nSampling (2 threads)  38%|███████████▍                  |  ETA: 0:00:24\nSampling (2 threads)  38%|███████████▌                  |  ETA: 0:00:24\nSampling (2 threads)  39%|███████████▊                  |  ETA: 0:00:23\nSampling (2 threads)  40%|███████████▉                  |  ETA: 0:00:23\nSampling (2 threads)  40%|████████████                  |  ETA: 0:00:23\nSampling (2 threads)  40%|████████████▏                 |  ETA: 0:00:22\nSampling (2 threads)  41%|████████████▎                 |  ETA: 0:00:22\nSampling (2 threads)  42%|████████████▌                 |  ETA: 0:00:21\nSampling (2 threads)  42%|████████████▋                 |  ETA: 0:00:21\nSampling (2 threads)  42%|████████████▊                 |  ETA: 0:00:20\nSampling (2 threads)  43%|████████████▉                 |  ETA: 0:00:20\nSampling (2 threads)  44%|█████████████                 |  ETA: 0:00:20\nSampling (2 threads)  44%|█████████████▎                |  ETA: 0:00:23\nSampling (2 threads)  44%|█████████████▍                |  ETA: 0:00:23\n┌ Info: Found initial step size\n└   ϵ = 1.0\nSampling (2 threads)  45%|█████████████▌                |  ETA: 0:00:22\nSampling (2 threads)  46%|█████████████▋                |  ETA: 0:00:22\nSampling (2 threads)  46%|█████████████▊                |  ETA: 0:00:21\nSampling (2 threads)  46%|██████████████                |  ETA: 0:00:21\nSampling (2 threads)  47%|██████████████▏               |  ETA: 0:00:21\nSampling (2 threads)  48%|██████████████▎               |  ETA: 0:00:20\nSampling (2 threads)  48%|██████████████▍               |  ETA: 0:00:20\nSampling (2 threads)  48%|██████████████▌               |  ETA: 0:00:19\nSampling (2 threads)  49%|██████████████▊               |  ETA: 0:00:19\nSampling (2 threads)  50%|██████████████▉               |  ETA: 0:00:19\nSampling (2 threads)  50%|███████████████               |  ETA: 0:00:18\nSampling (2 threads)  50%|███████████████▏              |  ETA: 0:00:18\nSampling (2 threads)  51%|███████████████▎              |  ETA: 0:00:18\nSampling (2 threads)  52%|███████████████▌              |  ETA: 0:00:17\nSampling (2 threads)  52%|███████████████▋              |  ETA: 0:00:17\nSampling (2 threads)  52%|███████████████▊              |  ETA: 0:00:17\nSampling (2 threads)  53%|███████████████▉              |  ETA: 0:00:16\nSampling (2 threads)  54%|████████████████              |  ETA: 0:00:16\nSampling (2 threads)  54%|████████████████▎             |  ETA: 0:00:16\nSampling (2 threads)  55%|████████████████▍             |  ETA: 0:00:15\nSampling (2 threads)  55%|████████████████▌             |  ETA: 0:00:15\nSampling (2 threads)  56%|████████████████▋             |  ETA: 0:00:15\nSampling (2 threads)  56%|████████████████▊             |  ETA: 0:00:15\nSampling (2 threads)  56%|█████████████████             |  ETA: 0:00:14\nSampling (2 threads)  57%|█████████████████▏            |  ETA: 0:00:14\nSampling (2 threads)  57%|█████████████████▎            |  ETA: 0:00:14\n┌ Info: Found initial step size\n└   ϵ = 0.2\nSampling (2 threads)  58%|█████████████████▍            |  ETA: 0:00:13\nSampling (2 threads)  58%|█████████████████▌            |  ETA: 0:00:13\nSampling (2 threads)  59%|█████████████████▊            |  ETA: 0:00:13\nSampling (2 threads)  60%|█████████████████▉            |  ETA: 0:00:13\nSampling (2 threads)  60%|██████████████████            |  ETA: 0:00:12\nSampling (2 threads)  60%|██████████████████▏           |  ETA: 0:00:12\nSampling (2 threads)  61%|██████████████████▎           |  ETA: 0:00:12\nSampling (2 threads)  62%|██████████████████▌           |  ETA: 0:00:12\nSampling (2 threads)  62%|██████████████████▋           |  ETA: 0:00:11\nSampling (2 threads)  62%|██████████████████▊           |  ETA: 0:00:11\nSampling (2 threads)  63%|██████████████████▉           |  ETA: 0:00:11\nSampling (2 threads)  64%|███████████████████           |  ETA: 0:00:11\nSampling (2 threads)  64%|███████████████████▎          |  ETA: 0:00:10\nSampling (2 threads)  64%|███████████████████▍          |  ETA: 0:00:10\nSampling (2 threads)  65%|███████████████████▌          |  ETA: 0:00:10\nSampling (2 threads)  66%|███████████████████▋          |  ETA: 0:00:10\nSampling (2 threads)  66%|███████████████████▊          |  ETA: 0:00:10\nSampling (2 threads)  66%|████████████████████          |  ETA: 0:00:09\nSampling (2 threads)  67%|████████████████████▏         |  ETA: 0:00:09\nSampling (2 threads)  68%|████████████████████▎         |  ETA: 0:00:09\nSampling (2 threads)  68%|████████████████████▍         |  ETA: 0:00:09\nSampling (2 threads)  68%|████████████████████▌         |  ETA: 0:00:09\nSampling (2 threads)  69%|████████████████████▊         |  ETA: 0:00:08\nSampling (2 threads)  70%|████████████████████▉         |  ETA: 0:00:08\nSampling (2 threads)  70%|█████████████████████         |  ETA: 0:00:08\nSampling (2 threads)  70%|█████████████████████▏        |  ETA: 0:00:08\nSampling (2 threads)  71%|█████████████████████▎        |  ETA: 0:00:08\nSampling (2 threads)  72%|█████████████████████▌        |  ETA: 0:00:07\nSampling (2 threads)  72%|█████████████████████▋        |  ETA: 0:00:07\nSampling (2 threads)  72%|█████████████████████▊        |  ETA: 0:00:07\nSampling (2 threads)  73%|█████████████████████▉        |  ETA: 0:00:07\nSampling (2 threads)  74%|██████████████████████        |  ETA: 0:00:07\nSampling (2 threads)  74%|██████████████████████▎       |  ETA: 0:00:07\nSampling (2 threads)  74%|██████████████████████▍       |  ETA: 0:00:06\nSampling (2 threads)  75%|██████████████████████▌       |  ETA: 0:00:06\nSampling (2 threads)  76%|██████████████████████▋       |  ETA: 0:00:06\nSampling (2 threads)  76%|██████████████████████▊       |  ETA: 0:00:06\nSampling (2 threads)  76%|███████████████████████       |  ETA: 0:00:06\nSampling (2 threads)  77%|███████████████████████▏      |  ETA: 0:00:06\nSampling (2 threads)  78%|███████████████████████▎      |  ETA: 0:00:05\nSampling (2 threads)  78%|███████████████████████▍      |  ETA: 0:00:05\nSampling (2 threads)  78%|███████████████████████▌      |  ETA: 0:00:05\nSampling (2 threads)  79%|███████████████████████▊      |  ETA: 0:00:05\nSampling (2 threads)  80%|███████████████████████▉      |  ETA: 0:00:05\nSampling (2 threads)  80%|████████████████████████      |  ETA: 0:00:05\nSampling (2 threads)  80%|████████████████████████▏     |  ETA: 0:00:05\nSampling (2 threads)  81%|████████████████████████▎     |  ETA: 0:00:04\nSampling (2 threads)  82%|████████████████████████▌     |  ETA: 0:00:04\nSampling (2 threads)  82%|████████████████████████▋     |  ETA: 0:00:04\nSampling (2 threads)  82%|████████████████████████▊     |  ETA: 0:00:04\nSampling (2 threads)  83%|████████████████████████▉     |  ETA: 0:00:04\nSampling (2 threads)  84%|█████████████████████████     |  ETA: 0:00:04\nSampling (2 threads)  84%|█████████████████████████▎    |  ETA: 0:00:04\nSampling (2 threads)  84%|█████████████████████████▍    |  ETA: 0:00:03\nSampling (2 threads)  85%|█████████████████████████▌    |  ETA: 0:00:03\nSampling (2 threads)  86%|█████████████████████████▋    |  ETA: 0:00:03\nSampling (2 threads)  86%|█████████████████████████▊    |  ETA: 0:00:03\nSampling (2 threads)  86%|██████████████████████████    |  ETA: 0:00:03\nSampling (2 threads)  87%|██████████████████████████▏   |  ETA: 0:00:03\nSampling (2 threads)  88%|██████████████████████████▎   |  ETA: 0:00:03\nSampling (2 threads)  88%|██████████████████████████▍   |  ETA: 0:00:03\nSampling (2 threads)  88%|██████████████████████████▌   |  ETA: 0:00:02\nSampling (2 threads)  89%|██████████████████████████▊   |  ETA: 0:00:02\nSampling (2 threads)  90%|██████████████████████████▉   |  ETA: 0:00:02\nSampling (2 threads)  90%|███████████████████████████   |  ETA: 0:00:02\nSampling (2 threads)  90%|███████████████████████████▏  |  ETA: 0:00:02\nSampling (2 threads)  91%|███████████████████████████▎  |  ETA: 0:00:02\nSampling (2 threads)  92%|███████████████████████████▌  |  ETA: 0:00:02\nSampling (2 threads)  92%|███████████████████████████▋  |  ETA: 0:00:02\nSampling (2 threads)  92%|███████████████████████████▊  |  ETA: 0:00:02\nSampling (2 threads)  93%|███████████████████████████▉  |  ETA: 0:00:01\nSampling (2 threads)  94%|████████████████████████████  |  ETA: 0:00:01\nSampling (2 threads)  94%|████████████████████████████▎ |  ETA: 0:00:01\nSampling (2 threads)  94%|████████████████████████████▍ |  ETA: 0:00:01\nSampling (2 threads)  95%|████████████████████████████▌ |  ETA: 0:00:01\nSampling (2 threads)  96%|████████████████████████████▋ |  ETA: 0:00:01\nSampling (2 threads)  96%|████████████████████████████▊ |  ETA: 0:00:01\nSampling (2 threads)  96%|█████████████████████████████ |  ETA: 0:00:01\nSampling (2 threads)  97%|█████████████████████████████▏|  ETA: 0:00:01\nSampling (2 threads)  98%|█████████████████████████████▎|  ETA: 0:00:00\nSampling (2 threads)  98%|█████████████████████████████▍|  ETA: 0:00:00\nSampling (2 threads)  98%|█████████████████████████████▌|  ETA: 0:00:00\nSampling (2 threads)  99%|█████████████████████████████▊|  ETA: 0:00:00\nSampling (2 threads) 100%|█████████████████████████████▉|  ETA: 0:00:00\nSampling (2 threads) 100%|██████████████████████████████| Time: 0:00:19\nSampling (2 threads) 100%|██████████████████████████████| Time: 0:00:19","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Most ArviZ functions work fine with Chains objects from Turing:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"plot_autocorr(turing_chns; var_names=(:μ, :τ));","category":"page"},{"location":"quickstart/#Convert-to-InferenceData","page":"Quickstart","title":"Convert to InferenceData","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"For much more powerful querying, analysis and plotting, we can use built-in ArviZ utilities to convert Chains objects to multidimensional data structures with named dimensions and indices. Note that for such dimensions, the information is not contained in Chains, so we need to provide it.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"ArviZ is built to work with InferenceData, and the more groups it has access to, the more powerful analyses it can perform.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"idata_turing_post = from_mcmcchains(\n    turing_chns;\n    coords=(; school=schools),\n    dims=NamedTuple(k => (:school,) for k in (:y, :σ, :θ)),\n    library=\"Turing\",\n)","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"<div>InferenceData<details>\n<summary>posterior</summary>\n<pre><span class=\"sgr90\">┌ </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">8</span> Dataset<span class=\"sgr90\"> ┐</span>\n<span class=\"sgr90\">├──────────────────┴──────────────────────────────────────────── dims ┐</span>\n  <span class=\"sgr38_5\" style=\"color:#ff875f\">↓ draw</span>,\n  <span class=\"sgr38_5\" style=\"color:#0087d7\">→ chain</span>,\n  <span class=\"sgr38_5\" style=\"color:#5fd7ff\">↗ school</span> Categorical{String} <span class=\"sgr38_5\" style=\"color:#5fd7ff\">[&quot;Choate&quot;, …, &quot;Mt. Hermon&quot;]</span> <span class=\"sgr38_5\" style=\"color:#808080\">Unordered</span>\n<span class=\"sgr90\">├───────────────────────────────────────────────────────────── layers ┤</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :μ</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :τ</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :θ</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span>, <span class=\"sgr38_5\" style=\"color:#5fd7ff\">school</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">8</span>\n<span class=\"sgr90\">├─────────────────────────────────────────────────────────── metadata ┤</span>\n  Dict{String, Any} with 2 entries:\n  &quot;created_at&quot; =&gt; &quot;2025-08-19T09:39:52.91&quot;\n  &quot;inference_library&quot; =&gt; &quot;Turing&quot;\n</pre></details>\n<details>\n<summary>sample_stats</summary>\n<pre><span class=\"sgr90\">┌ </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span> Dataset<span class=\"sgr90\"> ┐</span>\n<span class=\"sgr90\">├────────────────┴──────────────────────────────────────────── dims ┐</span>\n  <span class=\"sgr38_5\" style=\"color:#ff875f\">↓ draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">→ chain</span>\n<span class=\"sgr90\">├─────────────────────────────────────────────────────────── layers ┤</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :energy          </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :n_steps         </span><span class=\"sgr90\"> eltype: </span>Int64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :diverging       </span><span class=\"sgr90\"> eltype: </span>Bool<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :max_energy_error</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :loglikelihood   </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :energy_error    </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :is_accept       </span><span class=\"sgr90\"> eltype: </span>Bool<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :logprior        </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :log_density     </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :tree_depth      </span><span class=\"sgr90\"> eltype: </span>Int64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :step_size       </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :acceptance_rate </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :lp              </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :step_size_nom   </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr90\">├───────────────────────────────────────────────────────── metadata ┤</span>\n  Dict{String, Any} with 2 entries:\n  &quot;created_at&quot; =&gt; &quot;2025-08-19T09:39:52.832&quot;\n  &quot;inference_library&quot; =&gt; &quot;Turing&quot;\n</pre></details>\n</div>","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Each group is a Dataset, a DimensionalData.AbstractDimStack that can be used identically to a DimensionalData.Dimstack. We can view a summary of the dataset.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"idata_turing_post.posterior","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"┌ 1000×4×8 Dataset ┐\n├──────────────────┴──────────────────────────────────────────── dims ┐\n  ↓ draw,\n  → chain,\n  ↗ school Categorical{String} [\"Choate\", …, \"Mt. Hermon\"] Unordered\n├───────────────────────────────────────────────────────────── layers ┤\n  :μ eltype: Float64 dims: draw, chain size: 1000×4\n  :τ eltype: Float64 dims: draw, chain size: 1000×4\n  :θ eltype: Float64 dims: draw, chain, school size: 1000×4×8\n├─────────────────────────────────────────────────────────── metadata ┤\n  Dict{String, Any} with 2 entries:\n  \"created_at\"        => \"2025-08-19T09:39:52.91\"\n  \"inference_library\" => \"Turing\"","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Here is a plot of the trace. Note the intelligent labels.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"plot_trace(idata_turing_post);","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"We can also generate summary stats…","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"summarystats(idata_turing_post)","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"[TABLE]","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"SummaryStats","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"…and examine the energy distribution of the Hamiltonian sampler.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"plot_energy(idata_turing_post);","category":"page"},{"location":"quickstart/#Additional-information-in-Turing.jl","page":"Quickstart","title":"Additional information in Turing.jl","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"With a few more steps, we can use Turing to compute additional useful groups to add to the InferenceData.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"To sample from the prior, one simply calls sample but with the Prior sampler:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"prior = Turing.sample(rng2, param_mod_turing, Prior(), ndraws);","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Sampling   0%|                                          |  ETA: N/A\nSampling   0%|▎                                         |  ETA: 0:01:26\nSampling   1%|▍                                         |  ETA: 0:00:43\nSampling   2%|▋                                         |  ETA: 0:00:28\nSampling   2%|▉                                         |  ETA: 0:00:21\nSampling   2%|█                                         |  ETA: 0:00:17\nSampling   3%|█▎                                        |  ETA: 0:00:14\nSampling   4%|█▌                                        |  ETA: 0:00:12\nSampling   4%|█▋                                        |  ETA: 0:00:10\nSampling   4%|█▉                                        |  ETA: 0:00:09\nSampling   5%|██▏                                       |  ETA: 0:00:08\nSampling   6%|██▎                                       |  ETA: 0:00:08\nSampling   6%|██▌                                       |  ETA: 0:00:07\nSampling   6%|██▊                                       |  ETA: 0:00:06\nSampling   7%|███                                       |  ETA: 0:00:06\nSampling   8%|███▏                                      |  ETA: 0:00:05\nSampling   8%|███▍                                      |  ETA: 0:00:05\nSampling   8%|███▋                                      |  ETA: 0:00:05\nSampling   9%|███▊                                      |  ETA: 0:00:04\nSampling  10%|████                                      |  ETA: 0:00:04\nSampling  10%|████▎                                     |  ETA: 0:00:04\nSampling  10%|████▍                                     |  ETA: 0:00:04\nSampling  11%|████▋                                     |  ETA: 0:00:04\nSampling  12%|████▉                                     |  ETA: 0:00:03\nSampling  12%|█████                                     |  ETA: 0:00:03\nSampling  12%|█████▎                                    |  ETA: 0:00:03\nSampling  13%|█████▌                                    |  ETA: 0:00:03\nSampling  14%|█████▋                                    |  ETA: 0:00:03\nSampling  14%|█████▉                                    |  ETA: 0:00:03\nSampling  14%|██████▏                                   |  ETA: 0:00:03\nSampling  15%|██████▎                                   |  ETA: 0:00:03\nSampling  16%|██████▌                                   |  ETA: 0:00:02\nSampling  16%|██████▊                                   |  ETA: 0:00:02\nSampling  16%|██████▉                                   |  ETA: 0:00:02\nSampling  17%|███████▏                                  |  ETA: 0:00:02\nSampling  18%|███████▍                                  |  ETA: 0:00:02\nSampling  18%|███████▌                                  |  ETA: 0:00:02\nSampling  18%|███████▊                                  |  ETA: 0:00:02\nSampling  19%|████████                                  |  ETA: 0:00:02\nSampling  20%|████████▎                                 |  ETA: 0:00:02\nSampling  20%|████████▍                                 |  ETA: 0:00:02\nSampling  20%|████████▋                                 |  ETA: 0:00:02\nSampling  21%|████████▉                                 |  ETA: 0:00:02\nSampling  22%|█████████                                 |  ETA: 0:00:02\nSampling  22%|█████████▎                                |  ETA: 0:00:02\nSampling  22%|█████████▌                                |  ETA: 0:00:02\nSampling  23%|█████████▋                                |  ETA: 0:00:02\nSampling  24%|█████████▉                                |  ETA: 0:00:02\nSampling  24%|██████████▏                               |  ETA: 0:00:01\nSampling  24%|██████████▎                               |  ETA: 0:00:01\nSampling  25%|██████████▌                               |  ETA: 0:00:01\nSampling  26%|██████████▊                               |  ETA: 0:00:01\nSampling  26%|██████████▉                               |  ETA: 0:00:01\nSampling  26%|███████████▏                              |  ETA: 0:00:01\nSampling  27%|███████████▍                              |  ETA: 0:00:01\nSampling  28%|███████████▌                              |  ETA: 0:00:01\nSampling  28%|███████████▊                              |  ETA: 0:00:01\nSampling  28%|████████████                              |  ETA: 0:00:01\nSampling  29%|████████████▏                             |  ETA: 0:00:01\nSampling  30%|████████████▍                             |  ETA: 0:00:01\nSampling  30%|████████████▋                             |  ETA: 0:00:01\nSampling  30%|████████████▊                             |  ETA: 0:00:01\nSampling  31%|█████████████                             |  ETA: 0:00:01\nSampling  32%|█████████████▎                            |  ETA: 0:00:01\nSampling  32%|█████████████▌                            |  ETA: 0:00:01\nSampling  32%|█████████████▋                            |  ETA: 0:00:01\nSampling  33%|█████████████▉                            |  ETA: 0:00:01\nSampling  34%|██████████████▏                           |  ETA: 0:00:01\nSampling  34%|██████████████▎                           |  ETA: 0:00:01\nSampling  34%|██████████████▌                           |  ETA: 0:00:01\nSampling  35%|██████████████▊                           |  ETA: 0:00:01\nSampling  36%|██████████████▉                           |  ETA: 0:00:01\nSampling  36%|███████████████▏                          |  ETA: 0:00:01\nSampling  36%|███████████████▍                          |  ETA: 0:00:01\nSampling  37%|███████████████▌                          |  ETA: 0:00:01\nSampling  38%|███████████████▊                          |  ETA: 0:00:01\nSampling  38%|████████████████                          |  ETA: 0:00:01\nSampling  38%|████████████████▏                         |  ETA: 0:00:01\nSampling  39%|████████████████▍                         |  ETA: 0:00:01\nSampling  40%|████████████████▋                         |  ETA: 0:00:01\nSampling  40%|████████████████▊                         |  ETA: 0:00:01\nSampling  40%|█████████████████                         |  ETA: 0:00:01\nSampling  41%|█████████████████▎                        |  ETA: 0:00:01\nSampling  42%|█████████████████▍                        |  ETA: 0:00:01\nSampling  42%|█████████████████▋                        |  ETA: 0:00:01\nSampling  42%|█████████████████▉                        |  ETA: 0:00:01\nSampling  43%|██████████████████                        |  ETA: 0:00:01\nSampling  44%|██████████████████▎                       |  ETA: 0:00:01\nSampling  44%|██████████████████▌                       |  ETA: 0:00:01\nSampling  44%|██████████████████▊                       |  ETA: 0:00:01\nSampling  45%|██████████████████▉                       |  ETA: 0:00:01\nSampling  46%|███████████████████▏                      |  ETA: 0:00:01\nSampling  46%|███████████████████▍                      |  ETA: 0:00:01\nSampling  46%|███████████████████▌                      |  ETA: 0:00:01\nSampling  47%|███████████████████▊                      |  ETA: 0:00:01\nSampling  48%|████████████████████                      |  ETA: 0:00:01\nSampling  48%|████████████████████▏                     |  ETA: 0:00:01\nSampling  48%|████████████████████▍                     |  ETA: 0:00:01\nSampling  49%|████████████████████▋                     |  ETA: 0:00:01\nSampling  50%|████████████████████▊                     |  ETA: 0:00:01\nSampling  50%|█████████████████████                     |  ETA: 0:00:00\nSampling  50%|█████████████████████▎                    |  ETA: 0:00:00\nSampling  51%|█████████████████████▍                    |  ETA: 0:00:00\nSampling  52%|█████████████████████▋                    |  ETA: 0:00:00\nSampling  52%|█████████████████████▉                    |  ETA: 0:00:00\nSampling  52%|██████████████████████                    |  ETA: 0:00:00\nSampling  53%|██████████████████████▎                   |  ETA: 0:00:00\nSampling  54%|██████████████████████▌                   |  ETA: 0:00:00\nSampling  54%|██████████████████████▋                   |  ETA: 0:00:00\nSampling  55%|██████████████████████▉                   |  ETA: 0:00:00\nSampling  55%|███████████████████████▏                  |  ETA: 0:00:00\nSampling  56%|███████████████████████▎                  |  ETA: 0:00:00\nSampling  56%|███████████████████████▌                  |  ETA: 0:00:00\nSampling  56%|███████████████████████▊                  |  ETA: 0:00:00\nSampling  57%|████████████████████████                  |  ETA: 0:00:00\nSampling  57%|████████████████████████▏                 |  ETA: 0:00:00\nSampling  58%|████████████████████████▍                 |  ETA: 0:00:00\nSampling  58%|████████████████████████▋                 |  ETA: 0:00:00\nSampling  59%|████████████████████████▊                 |  ETA: 0:00:00\nSampling  60%|█████████████████████████                 |  ETA: 0:00:00\nSampling  60%|█████████████████████████▎                |  ETA: 0:00:00\nSampling  60%|█████████████████████████▍                |  ETA: 0:00:00\nSampling  61%|█████████████████████████▋                |  ETA: 0:00:00\nSampling  62%|█████████████████████████▉                |  ETA: 0:00:00\nSampling  62%|██████████████████████████                |  ETA: 0:00:00\nSampling  62%|██████████████████████████▎               |  ETA: 0:00:00\nSampling  63%|██████████████████████████▌               |  ETA: 0:00:00\nSampling  64%|██████████████████████████▋               |  ETA: 0:00:00\nSampling  64%|██████████████████████████▉               |  ETA: 0:00:00\nSampling  64%|███████████████████████████▏              |  ETA: 0:00:00\nSampling  65%|███████████████████████████▎              |  ETA: 0:00:00\nSampling  66%|███████████████████████████▌              |  ETA: 0:00:00\nSampling  66%|███████████████████████████▊              |  ETA: 0:00:00\nSampling  66%|███████████████████████████▉              |  ETA: 0:00:00\nSampling  67%|████████████████████████████▏             |  ETA: 0:00:00\nSampling  68%|████████████████████████████▍             |  ETA: 0:00:00\nSampling  68%|████████████████████████████▌             |  ETA: 0:00:00\nSampling  68%|████████████████████████████▊             |  ETA: 0:00:00\nSampling  69%|█████████████████████████████             |  ETA: 0:00:00\nSampling  70%|█████████████████████████████▎            |  ETA: 0:00:00\nSampling  70%|█████████████████████████████▍            |  ETA: 0:00:00\nSampling  70%|█████████████████████████████▋            |  ETA: 0:00:00\nSampling  71%|█████████████████████████████▉            |  ETA: 0:00:00\nSampling  72%|██████████████████████████████            |  ETA: 0:00:00\nSampling  72%|██████████████████████████████▎           |  ETA: 0:00:00\nSampling  72%|██████████████████████████████▌           |  ETA: 0:00:00\nSampling  73%|██████████████████████████████▋           |  ETA: 0:00:00\nSampling  74%|██████████████████████████████▉           |  ETA: 0:00:00\nSampling  74%|███████████████████████████████▏          |  ETA: 0:00:00\nSampling  74%|███████████████████████████████▎          |  ETA: 0:00:00\nSampling  75%|███████████████████████████████▌          |  ETA: 0:00:00\nSampling  76%|███████████████████████████████▊          |  ETA: 0:00:00\nSampling  76%|███████████████████████████████▉          |  ETA: 0:00:00\nSampling  76%|████████████████████████████████▏         |  ETA: 0:00:00\nSampling  77%|████████████████████████████████▍         |  ETA: 0:00:00\nSampling  78%|████████████████████████████████▌         |  ETA: 0:00:00\nSampling  78%|████████████████████████████████▊         |  ETA: 0:00:00\nSampling  78%|█████████████████████████████████         |  ETA: 0:00:00\nSampling  79%|█████████████████████████████████▏        |  ETA: 0:00:00\nSampling  80%|█████████████████████████████████▍        |  ETA: 0:00:00\nSampling  80%|█████████████████████████████████▋        |  ETA: 0:00:00\nSampling  80%|█████████████████████████████████▊        |  ETA: 0:00:00\nSampling  81%|██████████████████████████████████        |  ETA: 0:00:00\nSampling  82%|██████████████████████████████████▎       |  ETA: 0:00:00\nSampling  82%|██████████████████████████████████▌       |  ETA: 0:00:00\nSampling  82%|██████████████████████████████████▋       |  ETA: 0:00:00\nSampling  83%|██████████████████████████████████▉       |  ETA: 0:00:00\nSampling  84%|███████████████████████████████████▏      |  ETA: 0:00:00\nSampling  84%|███████████████████████████████████▎      |  ETA: 0:00:00\nSampling  84%|███████████████████████████████████▌      |  ETA: 0:00:00\nSampling  85%|███████████████████████████████████▊      |  ETA: 0:00:00\nSampling  86%|███████████████████████████████████▉      |  ETA: 0:00:00\nSampling  86%|████████████████████████████████████▏     |  ETA: 0:00:00\nSampling  86%|████████████████████████████████████▍     |  ETA: 0:00:00\nSampling  87%|████████████████████████████████████▌     |  ETA: 0:00:00\nSampling  88%|████████████████████████████████████▊     |  ETA: 0:00:00\nSampling  88%|█████████████████████████████████████     |  ETA: 0:00:00\nSampling  88%|█████████████████████████████████████▏    |  ETA: 0:00:00\nSampling  89%|█████████████████████████████████████▍    |  ETA: 0:00:00\nSampling  90%|█████████████████████████████████████▋    |  ETA: 0:00:00\nSampling  90%|█████████████████████████████████████▊    |  ETA: 0:00:00\nSampling  90%|██████████████████████████████████████    |  ETA: 0:00:00\nSampling  91%|██████████████████████████████████████▎   |  ETA: 0:00:00\nSampling  92%|██████████████████████████████████████▍   |  ETA: 0:00:00\nSampling  92%|██████████████████████████████████████▋   |  ETA: 0:00:00\nSampling  92%|██████████████████████████████████████▉   |  ETA: 0:00:00\nSampling  93%|███████████████████████████████████████   |  ETA: 0:00:00\nSampling  94%|███████████████████████████████████████▎  |  ETA: 0:00:00\nSampling  94%|███████████████████████████████████████▌  |  ETA: 0:00:00\nSampling  94%|███████████████████████████████████████▊  |  ETA: 0:00:00\nSampling  95%|███████████████████████████████████████▉  |  ETA: 0:00:00\nSampling  96%|████████████████████████████████████████▏ |  ETA: 0:00:00\nSampling  96%|████████████████████████████████████████▍ |  ETA: 0:00:00\nSampling  96%|████████████████████████████████████████▌ |  ETA: 0:00:00\nSampling  97%|████████████████████████████████████████▊ |  ETA: 0:00:00\nSampling  98%|█████████████████████████████████████████ |  ETA: 0:00:00\nSampling  98%|█████████████████████████████████████████▏|  ETA: 0:00:00\nSampling  98%|█████████████████████████████████████████▍|  ETA: 0:00:00\nSampling  99%|█████████████████████████████████████████▋|  ETA: 0:00:00\nSampling 100%|█████████████████████████████████████████▊|  ETA: 0:00:00\nSampling 100%|██████████████████████████████████████████| Time: 0:00:00\nSampling 100%|██████████████████████████████████████████| Time: 0:00:00","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"To draw from the prior and posterior predictive distributions we can instantiate a “predictive model”, i.e. a Turing model but with the observations set to missing, and then calling predict on the predictive model and the previously drawn samples:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"# Instantiate the predictive model\nparam_mod_predict = model_turing(similar(y, Missing), σ)\n# and then sample!\nprior_predictive = Turing.predict(rng2, param_mod_predict, prior)\nposterior_predictive = Turing.predict(rng2, param_mod_predict, turing_chns);","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"And to extract the pointwise log-likelihoods, which is useful if you want to compute metrics such as loo,","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"log_likelihood = let\n    log_likelihood = Turing.pointwise_loglikelihoods(\n        param_mod_turing, MCMCChains.get_sections(turing_chns, :parameters)\n    )\n    # Ensure the ordering of the loglikelihoods matches the ordering of `posterior_predictive`\n    ynames = string.(keys(posterior_predictive))\n    log_likelihood_y = getindex.(Ref(log_likelihood), ynames)\n    (; y=cat(log_likelihood_y...; dims=3))\nend;","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"This can then be included in the from_mcmcchains call from above:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"idata_turing = from_mcmcchains(\n    turing_chns;\n    posterior_predictive,\n    log_likelihood,\n    prior,\n    prior_predictive,\n    observed_data=(; y),\n    coords=(; school=schools),\n    dims=NamedTuple(k => (:school,) for k in (:y, :σ, :θ)),\n    library=Turing,\n)","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"<div>InferenceData<details>\n<summary>posterior</summary>\n<pre><span class=\"sgr90\">┌ </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">8</span> Dataset<span class=\"sgr90\"> ┐</span>\n<span class=\"sgr90\">├──────────────────┴──────────────────────────────────────────── dims ┐</span>\n  <span class=\"sgr38_5\" style=\"color:#ff875f\">↓ draw</span>,\n  <span class=\"sgr38_5\" style=\"color:#0087d7\">→ chain</span>,\n  <span class=\"sgr38_5\" style=\"color:#5fd7ff\">↗ school</span> Categorical{String} <span class=\"sgr38_5\" style=\"color:#5fd7ff\">[&quot;Choate&quot;, …, &quot;Mt. Hermon&quot;]</span> <span class=\"sgr38_5\" style=\"color:#808080\">Unordered</span>\n<span class=\"sgr90\">├───────────────────────────────────────────────────────────── layers ┤</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :μ</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :τ</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :θ</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span>, <span class=\"sgr38_5\" style=\"color:#5fd7ff\">school</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">8</span>\n<span class=\"sgr90\">├─────────────────────────────────────────────────────────── metadata ┤</span>\n  Dict{String, Any} with 3 entries:\n  &quot;created_at&quot; =&gt; &quot;2025-08-19T09:40:24.737&quot;\n  &quot;inference_library_version&quot; =&gt; &quot;0.40.2&quot;\n  &quot;inference_library&quot; =&gt; &quot;Turing&quot;\n</pre></details>\n<details>\n<summary>posterior_predictive</summary>\n<pre><span class=\"sgr90\">┌ </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">8</span> Dataset<span class=\"sgr90\"> ┐</span>\n<span class=\"sgr90\">├──────────────────┴──────────────────────────────────────────── dims ┐</span>\n  <span class=\"sgr38_5\" style=\"color:#ff875f\">↓ draw</span>,\n  <span class=\"sgr38_5\" style=\"color:#0087d7\">→ chain</span>,\n  <span class=\"sgr38_5\" style=\"color:#5fd7ff\">↗ school</span> Categorical{String} <span class=\"sgr38_5\" style=\"color:#5fd7ff\">[&quot;Choate&quot;, …, &quot;Mt. Hermon&quot;]</span> <span class=\"sgr38_5\" style=\"color:#808080\">Unordered</span>\n<span class=\"sgr90\">├───────────────────────────────────────────────────────────── layers ┤</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :y</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span>, <span class=\"sgr38_5\" style=\"color:#5fd7ff\">school</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">8</span>\n<span class=\"sgr90\">├─────────────────────────────────────────────────────────── metadata ┤</span>\n  Dict{String, Any} with 3 entries:\n  &quot;created_at&quot; =&gt; &quot;2025-08-19T09:40:24.274&quot;\n  &quot;inference_library_version&quot; =&gt; &quot;0.40.2&quot;\n  &quot;inference_library&quot; =&gt; &quot;Turing&quot;\n</pre></details>\n<details>\n<summary>log_likelihood</summary>\n<pre><span class=\"sgr90\">┌ </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">8</span> Dataset<span class=\"sgr90\"> ┐</span>\n<span class=\"sgr90\">├──────────────────┴──────────────────────────────────────────── dims ┐</span>\n  <span class=\"sgr38_5\" style=\"color:#ff875f\">↓ draw</span>,\n  <span class=\"sgr38_5\" style=\"color:#0087d7\">→ chain</span>,\n  <span class=\"sgr38_5\" style=\"color:#5fd7ff\">↗ school</span> Categorical{String} <span class=\"sgr38_5\" style=\"color:#5fd7ff\">[&quot;Choate&quot;, …, &quot;Mt. Hermon&quot;]</span> <span class=\"sgr38_5\" style=\"color:#808080\">Unordered</span>\n<span class=\"sgr90\">├───────────────────────────────────────────────────────────── layers ┤</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :y</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span>, <span class=\"sgr38_5\" style=\"color:#5fd7ff\">school</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">8</span>\n<span class=\"sgr90\">├─────────────────────────────────────────────────────────── metadata ┤</span>\n  Dict{String, Any} with 3 entries:\n  &quot;created_at&quot; =&gt; &quot;2025-08-19T09:40:24.577&quot;\n  &quot;inference_library_version&quot; =&gt; &quot;0.40.2&quot;\n  &quot;inference_library&quot; =&gt; &quot;Turing&quot;\n</pre></details>\n<details>\n<summary>sample_stats</summary>\n<pre><span class=\"sgr90\">┌ </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span> Dataset<span class=\"sgr90\"> ┐</span>\n<span class=\"sgr90\">├────────────────┴──────────────────────────────────────────── dims ┐</span>\n  <span class=\"sgr38_5\" style=\"color:#ff875f\">↓ draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">→ chain</span>\n<span class=\"sgr90\">├─────────────────────────────────────────────────────────── layers ┤</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :energy          </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :n_steps         </span><span class=\"sgr90\"> eltype: </span>Int64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :diverging       </span><span class=\"sgr90\"> eltype: </span>Bool<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :max_energy_error</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :loglikelihood   </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :energy_error    </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :is_accept       </span><span class=\"sgr90\"> eltype: </span>Bool<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :logprior        </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :log_density     </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :tree_depth      </span><span class=\"sgr90\"> eltype: </span>Int64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :step_size       </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :acceptance_rate </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :lp              </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :step_size_nom   </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr90\">├───────────────────────────────────────────────────────── metadata ┤</span>\n  Dict{String, Any} with 3 entries:\n  &quot;created_at&quot; =&gt; &quot;2025-08-19T09:40:24.737&quot;\n  &quot;inference_library_version&quot; =&gt; &quot;0.40.2&quot;\n  &quot;inference_library&quot; =&gt; &quot;Turing&quot;\n</pre></details>\n<details>\n<summary>prior</summary>\n<pre><span class=\"sgr90\">┌ </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">1</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">8</span> Dataset<span class=\"sgr90\"> ┐</span>\n<span class=\"sgr90\">├──────────────────┴──────────────────────────────────────────── dims ┐</span>\n  <span class=\"sgr38_5\" style=\"color:#ff875f\">↓ draw</span>,\n  <span class=\"sgr38_5\" style=\"color:#0087d7\">→ chain</span>,\n  <span class=\"sgr38_5\" style=\"color:#5fd7ff\">↗ school</span> Categorical{String} <span class=\"sgr38_5\" style=\"color:#5fd7ff\">[&quot;Choate&quot;, …, &quot;Mt. Hermon&quot;]</span> <span class=\"sgr38_5\" style=\"color:#808080\">Unordered</span>\n<span class=\"sgr90\">├───────────────────────────────────────────────────────────── layers ┤</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :μ</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">1</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :τ</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">1</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :θ</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span>, <span class=\"sgr38_5\" style=\"color:#5fd7ff\">school</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">1</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">8</span>\n<span class=\"sgr90\">├─────────────────────────────────────────────────────────── metadata ┤</span>\n  Dict{String, Any} with 3 entries:\n  &quot;created_at&quot; =&gt; &quot;2025-08-19T09:40:25.306&quot;\n  &quot;inference_library_version&quot; =&gt; &quot;0.40.2&quot;\n  &quot;inference_library&quot; =&gt; &quot;Turing&quot;\n</pre></details>\n<details>\n<summary>prior_predictive</summary>\n<pre><span class=\"sgr90\">┌ </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">1</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">8</span> Dataset<span class=\"sgr90\"> ┐</span>\n<span class=\"sgr90\">├──────────────────┴──────────────────────────────────────────── dims ┐</span>\n  <span class=\"sgr38_5\" style=\"color:#ff875f\">↓ draw</span>,\n  <span class=\"sgr38_5\" style=\"color:#0087d7\">→ chain</span>,\n  <span class=\"sgr38_5\" style=\"color:#5fd7ff\">↗ school</span> Categorical{String} <span class=\"sgr38_5\" style=\"color:#5fd7ff\">[&quot;Choate&quot;, …, &quot;Mt. Hermon&quot;]</span> <span class=\"sgr38_5\" style=\"color:#808080\">Unordered</span>\n<span class=\"sgr90\">├───────────────────────────────────────────────────────────── layers ┤</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :y</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span>, <span class=\"sgr38_5\" style=\"color:#5fd7ff\">school</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">1</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">8</span>\n<span class=\"sgr90\">├─────────────────────────────────────────────────────────── metadata ┤</span>\n  Dict{String, Any} with 3 entries:\n  &quot;created_at&quot; =&gt; &quot;2025-08-19T09:40:25.138&quot;\n  &quot;inference_library_version&quot; =&gt; &quot;0.40.2&quot;\n  &quot;inference_library&quot; =&gt; &quot;Turing&quot;\n</pre></details>\n<details>\n<summary>sample_stats_prior</summary>\n<pre><span class=\"sgr90\">┌ </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">1</span> Dataset<span class=\"sgr90\"> ┐</span>\n<span class=\"sgr90\">├────────────────┴───────────────────────────────────────── dims ┐</span>\n  <span class=\"sgr38_5\" style=\"color:#ff875f\">↓ draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">→ chain</span>\n<span class=\"sgr90\">├──────────────────────────────────────────────────────── layers ┤</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :logprior     </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">1</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :lp           </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">1</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :loglikelihood</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">1</span>\n<span class=\"sgr90\">├────────────────────────────────────────────────────── metadata ┤</span>\n  Dict{String, Any} with 3 entries:\n  &quot;created_at&quot; =&gt; &quot;2025-08-19T09:40:25.233&quot;\n  &quot;inference_library_version&quot; =&gt; &quot;0.40.2&quot;\n  &quot;inference_library&quot; =&gt; &quot;Turing&quot;\n</pre></details>\n<details>\n<summary>observed_data</summary>\n<pre><span class=\"sgr90\">┌ </span><span class=\"sgr38_5\" style=\"color:#ff875f\">8-element </span>Dataset<span class=\"sgr90\"> ┐</span>\n<span class=\"sgr90\">├───────────────────┴──────────────────────────────────────────── dims ┐</span>\n  <span class=\"sgr38_5\" style=\"color:#ff875f\">↓ school</span> Categorical{String} <span class=\"sgr38_5\" style=\"color:#ff875f\">[&quot;Choate&quot;, …, &quot;Mt. Hermon&quot;]</span> <span class=\"sgr38_5\" style=\"color:#808080\">Unordered</span>\n<span class=\"sgr90\">├────────────────────────────────────────────────────────────── layers ┤</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :y</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">school</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">8</span>\n<span class=\"sgr90\">├──────────────────────────────────────────────────────────── metadata ┤</span>\n  Dict{String, Any} with 3 entries:\n  &quot;created_at&quot; =&gt; &quot;2025-08-19T09:40:25.503&quot;\n  &quot;inference_library_version&quot; =&gt; &quot;0.40.2&quot;\n  &quot;inference_library&quot; =&gt; &quot;Turing&quot;\n</pre></details>\n</div>","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Then we can for example compute the expected leave-one-out (LOO) predictive density, which is an estimate of the out-of-distribution predictive fit of the model:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"loo(idata_turing) # higher ELPD is better","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"PSISLOOResult with estimates\n elpd  elpd_mcse    p  p_mcse \n  -31        1.4  0.9    0.33\n\nand PSISResult with 1000 draws, 4 chains, and 8 parameters\nPareto shape (k) diagnostic values:\n                    Count      Min. ESS\n (-Inf, 0.5]  good  6 (75.0%)  313\n  (0.5, 0.7]  okay  2 (25.0%)  1049","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"If the model is well-calibrated, i.e. it replicates the true generative process well, the CDF of the pointwise LOO values should be similarly distributed to a uniform distribution. This can be inspected visually:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"plot_loo_pit(idata_turing; y=:y, ecdf=true);","category":"page"},{"location":"quickstart/#Plotting-with-Stan.jl-outputs","page":"Quickstart","title":"Plotting with Stan.jl outputs","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"StanSample.jl comes with built-in support for producing InferenceData outputs.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Here is the same centered eight schools model in Stan:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"schools_code = \"\"\"\ndata {\n    int<lower=0> J;\n    array[J] real y;\n    array[J] real<lower=0> sigma;\n}\n\nparameters {\n    real mu;\n    real<lower=0> tau;\n    array[J] real theta;\n}\n\nmodel {\n    mu ~ normal(0, 5);\n    tau ~ cauchy(0, 5);\n    theta ~ normal(mu, tau);\n    y ~ normal(theta, sigma);\n}\n\ngenerated quantities {\n    vector[J] log_lik;\n    vector[J] y_hat;\n    for (j in 1:J) {\n        log_lik[j] = normal_lpdf(y[j] | theta[j], sigma[j]);\n        y_hat[j] = normal_rng(theta[j], sigma[j]);\n    }\n}\n\"\"\"\n\nschools_data = Dict(\"J\" => J, \"y\" => y, \"sigma\" => σ)\nidata_stan = mktempdir() do path\n    stan_model = SampleModel(\"schools\", schools_code, path)\n    _ = stan_sample(\n        stan_model;\n        data=schools_data,\n        num_chains=nchains,\n        num_warmups=ndraws_warmup,\n        num_samples=ndraws,\n        seed=28983,\n        summary=false,\n    )\n    return StanSample.inferencedata(\n        stan_model;\n        posterior_predictive_var=:y_hat,\n        observed_data=(; y),\n        log_likelihood_var=:log_lik,\n        coords=(; school=schools),\n        dims=NamedTuple(\n            k => (:school,) for k in (:y, :sigma, :theta, :log_lik, :y_hat)\n        ),\n    )\nend","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"[ Info: /tmp/jl_q9qkTM/schools.stan updated.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"<div>InferenceData<details>\n<summary>posterior</summary>\n<pre><span class=\"sgr90\">┌ </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">8</span> Dataset<span class=\"sgr90\"> ┐</span>\n<span class=\"sgr90\">├──────────────────┴──────────────────────────────────────────── dims ┐</span>\n  <span class=\"sgr38_5\" style=\"color:#ff875f\">↓ draw</span>,\n  <span class=\"sgr38_5\" style=\"color:#0087d7\">→ chain</span>,\n  <span class=\"sgr38_5\" style=\"color:#5fd7ff\">↗ school</span> Categorical{String} <span class=\"sgr38_5\" style=\"color:#5fd7ff\">[&quot;Choate&quot;, …, &quot;Mt. Hermon&quot;]</span> <span class=\"sgr38_5\" style=\"color:#808080\">Unordered</span>\n<span class=\"sgr90\">├───────────────────────────────────────────────────────────── layers ┤</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :mu   </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :tau  </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :theta</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span>, <span class=\"sgr38_5\" style=\"color:#5fd7ff\">school</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">8</span>\n<span class=\"sgr90\">├─────────────────────────────────────────────────────────── metadata ┤</span>\n  Dict{String, Any} with 1 entry:\n  &quot;created_at&quot; =&gt; &quot;2025-08-19T09:41:06.675&quot;\n</pre></details>\n<details>\n<summary>posterior_predictive</summary>\n<pre><span class=\"sgr90\">┌ </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">8</span> Dataset<span class=\"sgr90\"> ┐</span>\n<span class=\"sgr90\">├──────────────────┴──────────────────────────────────────────── dims ┐</span>\n  <span class=\"sgr38_5\" style=\"color:#ff875f\">↓ draw</span>,\n  <span class=\"sgr38_5\" style=\"color:#0087d7\">→ chain</span>,\n  <span class=\"sgr38_5\" style=\"color:#5fd7ff\">↗ school</span> Categorical{String} <span class=\"sgr38_5\" style=\"color:#5fd7ff\">[&quot;Choate&quot;, …, &quot;Mt. Hermon&quot;]</span> <span class=\"sgr38_5\" style=\"color:#808080\">Unordered</span>\n<span class=\"sgr90\">├───────────────────────────────────────────────────────────── layers ┤</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :y_hat</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span>, <span class=\"sgr38_5\" style=\"color:#5fd7ff\">school</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">8</span>\n<span class=\"sgr90\">├─────────────────────────────────────────────────────────── metadata ┤</span>\n  Dict{String, Any} with 1 entry:\n  &quot;created_at&quot; =&gt; &quot;2025-08-19T09:41:06.262&quot;\n</pre></details>\n<details>\n<summary>log_likelihood</summary>\n<pre><span class=\"sgr90\">┌ </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">8</span> Dataset<span class=\"sgr90\"> ┐</span>\n<span class=\"sgr90\">├──────────────────┴──────────────────────────────────────────── dims ┐</span>\n  <span class=\"sgr38_5\" style=\"color:#ff875f\">↓ draw</span>,\n  <span class=\"sgr38_5\" style=\"color:#0087d7\">→ chain</span>,\n  <span class=\"sgr38_5\" style=\"color:#5fd7ff\">↗ school</span> Categorical{String} <span class=\"sgr38_5\" style=\"color:#5fd7ff\">[&quot;Choate&quot;, …, &quot;Mt. Hermon&quot;]</span> <span class=\"sgr38_5\" style=\"color:#808080\">Unordered</span>\n<span class=\"sgr90\">├───────────────────────────────────────────────────────────── layers ┤</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :log_lik</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span>, <span class=\"sgr38_5\" style=\"color:#5fd7ff\">school</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">8</span>\n<span class=\"sgr90\">├─────────────────────────────────────────────────────────── metadata ┤</span>\n  Dict{String, Any} with 1 entry:\n  &quot;created_at&quot; =&gt; &quot;2025-08-19T09:41:06.584&quot;\n</pre></details>\n<details>\n<summary>sample_stats</summary>\n<pre><span class=\"sgr90\">┌ </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span> Dataset<span class=\"sgr90\"> ┐</span>\n<span class=\"sgr90\">├────────────────┴─────────────────────────────────────────── dims ┐</span>\n  <span class=\"sgr38_5\" style=\"color:#ff875f\">↓ draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">→ chain</span>\n<span class=\"sgr90\">├────────────────────────────────────────────────────────── layers ┤</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :tree_depth     </span><span class=\"sgr90\"> eltype: </span>Int64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :energy         </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :diverging      </span><span class=\"sgr90\"> eltype: </span>Bool<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :acceptance_rate</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :n_steps        </span><span class=\"sgr90\"> eltype: </span>Int64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :lp             </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :step_size      </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">1000</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr90\">├──────────────────────────────────────────────────────── metadata ┤</span>\n  Dict{String, Any} with 1 entry:\n  &quot;created_at&quot; =&gt; &quot;2025-08-19T09:41:06.401&quot;\n</pre></details>\n<details>\n<summary>observed_data</summary>\n<pre><span class=\"sgr90\">┌ </span><span class=\"sgr38_5\" style=\"color:#ff875f\">8-element </span>Dataset<span class=\"sgr90\"> ┐</span>\n<span class=\"sgr90\">├───────────────────┴──────────────────────────────────────────── dims ┐</span>\n  <span class=\"sgr38_5\" style=\"color:#ff875f\">↓ school</span> Categorical{String} <span class=\"sgr38_5\" style=\"color:#ff875f\">[&quot;Choate&quot;, …, &quot;Mt. Hermon&quot;]</span> <span class=\"sgr38_5\" style=\"color:#808080\">Unordered</span>\n<span class=\"sgr90\">├────────────────────────────────────────────────────────────── layers ┤</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :y</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">school</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">8</span>\n<span class=\"sgr90\">├──────────────────────────────────────────────────────────── metadata ┤</span>\n  Dict{String, Any} with 1 entry:\n  &quot;created_at&quot; =&gt; &quot;2025-08-19T09:41:06.731&quot;\n</pre></details>\n</div>","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"plot_density(idata_stan; var_names=(:mu, :tau));","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Here is a plot showing where the Hamiltonian sampler had divergences:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"plot_pair(\n    idata_stan;\n    coords=Dict(:school => [\"Choate\", \"Deerfield\", \"Phillips Andover\"]),\n    divergences=true,\n);","category":"page"},{"location":"quickstart/#Environment","page":"Quickstart","title":"Environment","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"using Pkg\nPkg.status()","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Status `~/work/ArviZ.jl/ArviZ.jl/docs/Project.toml`\n⌃ [cbdf2221] AlgebraOfGraphics v0.11.4\n  [131c737c] ArviZ v0.12.3 `~/work/ArviZ.jl/ArviZ.jl`\n  [2f96bb34] ArviZExampleData v0.2.0\n  [4a6e88f0] ArviZPythonPlots v0.1.9\n  [13f3f980] CairoMakie v0.15.6\n  [a93c6f00] DataFrames v1.7.0\n  [0703355e] DimensionalData v0.29.23\n  [31c24e10] Distributions v0.25.120\n  [e30172f5] Documenter v1.14.1\n  [f6006082] EvoTrees v0.17.4\n  [b5cf5a8d] InferenceObjects v0.4.12\n  [be115224] MCMCDiagnosticTools v0.3.15\n  [a7f614a8] MLJBase v1.8.2\n  [614be32b] MLJIteration v0.6.3\n  [ce719bf2] PSIS v0.9.8\n  [7f36be82] PosteriorStats v0.2.8\n  [c1514b29] StanSample v7.10.2\n  [a19d573c] StatisticalMeasures v0.2.1\n  [10745b16] Statistics v1.11.1\n  [2913bbd2] StatsBase v0.34.6\n  [fce5fe82] Turing v0.40.2\n  [f43a241f] Downloads v1.6.0\n  [37e2e46d] LinearAlgebra v1.11.0\nInfo Packages marked with ⌃ have new versions available and may be upgradable.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"versioninfo()","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Julia Version 1.11.6\nCommit 9615af0f269 (2025-07-09 12:58 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 4 × AMD EPYC 7763 64-Core Processor\n  WORD_SIZE: 64\n  LLVM: libLLVM-16.0.6 (ORCJIT, znver3)\nThreads: 2 default, 0 interactive, 1 GC (on 4 virtual cores)\nEnvironment:\n  JULIA_PKG_SERVER_REGISTRY_PREFERENCE = eager\n  JULIA_PROJECT = @.\n  JULIA_NUM_THREADS = 2\n  JULIA_LOAD_PATH = @:@stdlib\n  JULIA_PYTHONCALL_EXE = /home/runner/work/ArviZ.jl/ArviZ.jl/docs/.CondaPkg/.pixi/envs/default/bin/python","category":"page"},{"location":"api/data/#data-api","page":"Data","title":"Data","text":"","category":"section"},{"location":"api/data/","page":"Data","title":"Data","text":"Pages = [\"data.md\"]","category":"page"},{"location":"api/data/#Inference-library-converters","page":"Data","title":"Inference library converters","text":"","category":"section"},{"location":"api/data/#ArviZ.from_mcmcchains","page":"Data","title":"ArviZ.from_mcmcchains","text":"from_mcmcchains(posterior::MCMCChains.Chains; kwargs...) -> InferenceData\nfrom_mcmcchains(; kwargs...) -> InferenceData\nfrom_mcmcchains(\n    posterior::MCMCChains.Chains,\n    posterior_predictive,\n    predictions,\n    log_likelihood;\n    kwargs...\n) -> InferenceData\n\nConvert data in an MCMCChains.Chains format into an InferenceData.\n\nAny keyword argument below without an an explicitly annotated type above is allowed, so long as it can be passed to convert_to_inference_data.\n\nArguments\n\nposterior::MCMCChains.Chains: Draws from the posterior\n\nKeywords\n\nposterior_predictive::Any=nothing: Draws from the posterior predictive distribution or   name(s) of predictive variables in posterior\npredictions: Out-of-sample predictions for the posterior.\nprior: Draws from the prior\nprior_predictive: Draws from the prior predictive distribution or name(s) of predictive   variables in prior\nobserved_data: Observed data on which the posterior is conditional. It should only   contain data which is modeled as a random variable. Keys are parameter names and values.\nconstant_data: Model constants, data included in the model that are not modeled as   random variables. Keys are parameter names.\npredictions_constant_data: Constants relevant to the model predictions (i.e. new x   values in a linear regression).\nlog_likelihood: Pointwise log-likelihood for the data. It is recommended to use this   argument as a named tuple whose keys are observed variable names and whose values are log   likelihood arrays. Alternatively, provide the name of variable in posterior containing   log likelihoods.\nlibrary=MCMCChains: Name of library that generated the chains\ncoords: Map from named dimension to named indices\ndims: Map from variable name to names of its dimensions\neltypes: Map from variable names to eltypes. This is primarily used to assign discrete   eltypes to discrete variables that were stored in Chains as floats.\n\nReturns\n\nInferenceData: The data with groups corresponding to the provided data\n\n\n\n\n\n","category":"function"},{"location":"api/data/#ArviZ.from_samplechains","page":"Data","title":"ArviZ.from_samplechains","text":"from_samplechains(\n    posterior=nothing;\n    prior=nothing,\n    library=SampleChains,\n    kwargs...,\n) -> InferenceData\n\nConvert SampleChains samples to an InferenceData.\n\nEither posterior or prior may be a SampleChains.AbstractChain or SampleChains.MultiChain object.\n\nFor descriptions of remaining kwargs, see from_namedtuple.\n\n\n\n\n\n","category":"function"},{"location":"api/data/#IO-/-Conversion","page":"Data","title":"IO / Conversion","text":"","category":"section"},{"location":"api/data/#InferenceObjects.from_netcdf","page":"Data","title":"InferenceObjects.from_netcdf","text":"from_netcdf(path::AbstractString; kwargs...) -> InferenceData\n\nLoad an InferenceData from an unopened NetCDF file.\n\nRemaining kwargs are passed to NCDatasets.NCDataset. This method loads data eagerly. To instead load data lazily, pass an opened NCDataset to from_netcdf.\n\nnote: Note\nThis method requires that NCDatasets is loaded before it can be used.\n\nExamples\n\njulia> using InferenceObjects, NCDatasets\n\njulia> idata = from_netcdf(\"centered_eight.nc\")\nInferenceData with groups:\n  > posterior\n  > posterior_predictive\n  > sample_stats\n  > prior\n  > observed_data\n\nfrom_netcdf(ds::NCDatasets.NCDataset; load_mode) -> InferenceData\n\nLoad an InferenceData from an opened NetCDF file.\n\nload_mode defaults to :lazy, which avoids reading variables into memory. Operations on these arrays will be slow. load_mode can also be :eager, which copies all variables into memory. It is then safe to close ds. If load_mode is :lazy and ds is closed after constructing InferenceData, using the variable arrays will have undefined behavior.\n\nExamples\n\nHere is how we might load an InferenceData from an InferenceData lazily from a web-hosted NetCDF file.\n\njulia> using HTTP, InferenceObjects, NCDatasets\n\njulia> resp = HTTP.get(\"https://github.com/arviz-devs/arviz_example_data/blob/main/data/centered_eight.nc?raw=true\");\n\njulia> ds = NCDataset(\"centered_eight\", \"r\"; memory = resp.body);\n\njulia> idata = from_netcdf(ds)\nInferenceData with groups:\n  > posterior\n  > posterior_predictive\n  > sample_stats\n  > prior\n  > observed_data\n\njulia> idata_copy = copy(idata); # disconnect from the loaded dataset\n\njulia> close(ds);\n\n\n\n\n\n","category":"function"},{"location":"api/data/#InferenceObjects.to_netcdf","page":"Data","title":"InferenceObjects.to_netcdf","text":"to_netcdf(data, dest::AbstractString; group::Symbol=:posterior, kwargs...)\nto_netcdf(data, dest::NCDatasets.NCDataset; group::Symbol=:posterior)\n\nWrite data to a NetCDF file.\n\ndata is any type that can be converted to an InferenceData using convert_to_inference_data. If not an InferenceData, then group specifies which group the data represents.\n\ndest specifies either the path to the NetCDF file or an opened NetCDF file. If dest is a path, remaining kwargs are passed to NCDatasets.NCDataset.\n\nnote: Note\nThis method requires that NCDatasets is loaded before it can be used.\n\nExamples\n\njulia> using InferenceObjects, NCDatasets\n\njulia> idata = from_namedtuple((; x = randn(4, 100, 3), z = randn(4, 100)))\nInferenceData with groups:\n  > posterior\n\njulia> to_netcdf(idata, \"data.nc\")\n\"data.nc\"\n\n\n\n\n\n","category":"function"},{"location":"api/diagnostics/#diagnostics-api","page":"Diagnostics","title":"Diagnostics","text":"","category":"section"},{"location":"api/diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"Pages = [\"diagnostics.md\"]","category":"page"},{"location":"api/diagnostics/#bfmi","page":"Diagnostics","title":"Bayesian fraction of missing information","text":"","category":"section"},{"location":"api/diagnostics/#MCMCDiagnosticTools.bfmi","page":"Diagnostics","title":"MCMCDiagnosticTools.bfmi","text":"bfmi(energy::AbstractVector{<:Real}) -> Real\nbfmi(energy::AbstractMatrix{<:Real}; dims::Int=1) -> AbstractVector{<:Real}\n\nCalculate the estimated Bayesian fraction of missing information (BFMI).\n\nWhen sampling with Hamiltonian Monte Carlo (HMC), BFMI quantifies how well momentum resampling matches the marginal energy distribution.\n\nThe current advice is that values smaller than 0.3 indicate poor sampling. However, this threshold is provisional and may change. A BFMI value below the threshold often indicates poor adaptation of sampling parameters or that the target distribution has heavy tails that were not well explored by the Markov chain.\n\nFor more information, see Section 6.1 of [Betancourt2018] or [Betancourt2016] for a complete account.\n\nenergy is either a vector of Hamiltonian energies of draws or a matrix of energies of draws for multiple chains. dims indicates the dimension in energy that contains the draws. The default dims=1 assumes energy has the shape draws or (draws, chains). If a different shape is provided, dims must be set accordingly.\n\nIf energy is a vector, a single BFMI value is returned. Otherwise, a vector of BFMI values for each chain is returned.\n\n[Betancourt2018]: Betancourt M. (2018). A Conceptual Introduction to Hamiltonian Monte Carlo. arXiv:1701.02434v2 [stat.ME]\n\n[Betancourt2016]: Betancourt M. (2016). Diagnosing Suboptimal Cotangent Disintegrations in Hamiltonian Monte Carlo. arXiv:1604.00695v1 [stat.ME]\n\n\n\n\n\n","category":"function"},{"location":"api/diagnostics/#ess_rhat","page":"Diagnostics","title":"Effective sample size and widehatR diagnostic","text":"","category":"section"},{"location":"api/diagnostics/#MCMCDiagnosticTools.ess","page":"Diagnostics","title":"MCMCDiagnosticTools.ess","text":"ess(data::InferenceData; kwargs...) -> Dataset\ness(data::Dataset; kwargs...) -> Dataset\n\nCalculate the effective sample size (ESS) for each parameter in the data.\n\nFor more details and a description of the kwargs, see MCMCDiagnosticTools.ess.\n\n\n\n\n\ness(\n    samples::AbstractArray{<:Union{Missing,Real}};\n    kind=:bulk,\n    relative::Bool=false,\n    autocov_method=AutocovMethod(),\n    split_chains::Int=2,\n    maxlag::Int=250,\n    kwargs...\n)\n\nEstimate the effective sample size (ESS) of the samples of shape (draws, [chains[, parameters...]]) with the autocov_method.\n\nOptionally, the kind of ESS estimate to be computed can be specified (see below). Some kinds accept additional kwargs.\n\nIf relative is true, the relative ESS is returned, i.e. ess / (draws * chains).\n\nsplit_chains indicates the number of chains each chain is split into. When split_chains > 1, then the diagnostics check for within-chain convergence. When d = mod(draws, split_chains) > 0, i.e. the chains cannot be evenly split, then 1 draw is discarded after each of the first d splits within each chain. There must be at least 3 draws in each chain after splitting.\n\nmaxlag indicates the maximum lag for which autocovariance is computed and must be greater than 0.\n\nFor a given estimand, it is recommended that the ESS is at least 100 * chains and that widehatR  101.[VehtariGelman2021]\n\nSee also: AutocovMethod, FFTAutocovMethod, BDAAutocovMethod, rhat, ess_rhat, mcse\n\nKinds of ESS estimates\n\nIf kind isa a Symbol, it may take one of the following values:\n\n:bulk: basic ESS computed on rank-normalized draws. This kind diagnoses poor convergence   in the bulk of the distribution due to trends or different locations of the chains.\n:tail: minimum of the quantile-ESS for the symmetric quantiles where   tail_prob=0.1 is the probability in the tails. This kind diagnoses poor convergence in   the tails of the distribution. If this kind is chosen, kwargs may contain a   tail_prob keyword.\n:basic: basic ESS, equivalent to specifying kind=Statistics.mean.\n\nnote: Note\nWhile Bulk-ESS is conceptually related to basic ESS, it is well-defined even if the chains do not have finite variance.[VehtariGelman2021] For each parameter, rank-normalization proceeds by first ranking the inputs using \"tied ranking\" and then transforming the ranks to normal quantiles so that the result is standard normally distributed. This transform is monotonic.\n\nOtherwise, kind specifies one of the following estimators, whose ESS is to be estimated:\n\nStatistics.mean\nStatistics.median\nStatistics.std\nStatsBase.mad\nBase.Fix2(Statistics.quantile, p::Real)\n\n[VehtariGelman2021]: Vehtari, A., Gelman, A., Simpson, D., Carpenter, B., & Bürkner, P. C. (2021). Rank-normalization, folding, and localization: An improved widehat R for assessing convergence of MCMC. Bayesian Analysis. doi: 10.1214/20-BA1221 arXiv: 1903.08008\n\n\n\n\n\n","category":"function"},{"location":"api/diagnostics/#MCMCDiagnosticTools.rhat","page":"Diagnostics","title":"MCMCDiagnosticTools.rhat","text":"rhat(data::InferenceData; kwargs...) -> Dataset\nrhat(data::Dataset; kwargs...) -> Dataset\n\nCalculate the widehatR diagnostic for each parameter in the data.\n\nFor more details and a description of the kwargs, see MCMCDiagnosticTools.rhat.\n\n\n\n\n\nrhat(samples::AbstractArray{Union{Real,Missing}}; kind::Symbol=:rank, split_chains=2)\n\nCompute the widehatR diagnostics for each parameter in samples of shape (draws, [chains[, parameters...]]).[VehtariGelman2021]\n\nkind indicates the kind of widehatR to compute (see below).\n\nsplit_chains indicates the number of chains each chain is split into. When split_chains > 1, then the diagnostics check for within-chain convergence. When d = mod(draws, split_chains) > 0, i.e. the chains cannot be evenly split, then 1 draw is discarded after each of the first d splits within each chain.\n\nSee also ess, ess_rhat, rstar\n\nKinds of widehatR\n\nThe following kinds are supported:\n\n:rank: maximum of widehatR with kind=:bulk and kind=:tail.\n:bulk: basic widehatR computed on rank-normalized draws. This kind diagnoses   poor convergence in the bulk of the distribution due to trends or different locations of   the chains.\n:tail: widehatR computed on draws folded around the median and then   rank-normalized. This kind diagnoses poor convergence in the tails of the distribution   due to different scales of the chains.\n:basic: Classic widehatR.\n\n[VehtariGelman2021]: Vehtari, A., Gelman, A., Simpson, D., Carpenter, B., & Bürkner, P. C. (2021). Rank-normalization, folding, and localization: An improved widehat R for assessing convergence of MCMC. Bayesian Analysis. doi: 10.1214/20-BA1221 arXiv: 1903.08008\n\n\n\n\n\n","category":"function"},{"location":"api/diagnostics/#MCMCDiagnosticTools.ess_rhat","page":"Diagnostics","title":"MCMCDiagnosticTools.ess_rhat","text":"ess_rhat(data::InferenceData; kwargs...) -> Dataset\ness_rhat(data::Dataset; kwargs...) -> Dataset\n\nCalculate the effective sample size (ESS) and widehatR diagnostic for each parameter in the data.\n\nFor more details and a description of the kwargs, see MCMCDiagnosticTools.ess_rhat.\n\n\n\n\n\ness_rhat(\n    samples::AbstractArray{<:Union{Missing,Real}};\n    kind::Symbol=:rank,\n    kwargs...,\n) -> NamedTuple{(:ess, :rhat)}\n\nEstimate the effective sample size and widehatR of the samples of shape (draws, [chains[, parameters...]]).\n\nWhen both ESS and widehatR are needed, this method is often more efficient than calling ess and rhat separately.\n\nSee rhat for a description of supported kinds and ess for a description of kwargs.\n\n\n\n\n\n","category":"function"},{"location":"api/diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"The following autocovariance methods are supported:","category":"page"},{"location":"api/diagnostics/#MCMCDiagnosticTools.AutocovMethod","page":"Diagnostics","title":"MCMCDiagnosticTools.AutocovMethod","text":"AutocovMethod <: AbstractAutocovMethod\n\nThe AutocovMethod uses a standard algorithm for estimating the mean autocovariance of MCMC chains.\n\nIt is is based on the discussion by [VehtariGelman2021] and uses the biased estimator of the autocovariance, as discussed by [Geyer1992].\n\n[VehtariGelman2021]: Vehtari, A., Gelman, A., Simpson, D., Carpenter, B., & Bürkner, P. C. (2021). Rank-normalization, folding, and localization: An improved widehat R for assessing convergence of MCMC. Bayesian Analysis. doi: 10.1214/20-BA1221 arXiv: 1903.08008\n\n[Geyer1992]: Geyer, C. J. (1992). Practical Markov Chain Monte Carlo. Statistical Science, 473-483.\n\n\n\n\n\n","category":"type"},{"location":"api/diagnostics/#MCMCDiagnosticTools.FFTAutocovMethod","page":"Diagnostics","title":"MCMCDiagnosticTools.FFTAutocovMethod","text":"FFTAutocovMethod <: AbstractAutocovMethod\n\nThe FFTAutocovMethod uses a standard algorithm for estimating the mean autocovariance of MCMC chains.\n\nThe algorithm is the same as the one of AutocovMethod but this method uses fast Fourier transforms (FFTs) for estimating the autocorrelation.\n\ninfo: Info\nTo be able to use this method, you have to load a package that implements the AbstractFFTs.jl interface such as FFTW.jl or FastTransforms.jl.\n\n\n\n\n\n","category":"type"},{"location":"api/diagnostics/#MCMCDiagnosticTools.BDAAutocovMethod","page":"Diagnostics","title":"MCMCDiagnosticTools.BDAAutocovMethod","text":"BDAAutocovMethod <: AbstractAutocovMethod\n\nThe BDAAutocovMethod uses a standard algorithm for estimating the mean autocovariance of MCMC chains.\n\nIt is is based on the discussion by [VehtariGelman2021]. and uses the variogram estimator of the autocorrelation function discussed by [BDA3].\n\n[VehtariGelman2021]: Vehtari, A., Gelman, A., Simpson, D., Carpenter, B., & Bürkner, P. C. (2021). Rank-normalization, folding, and localization: An improved widehat R for assessing convergence of MCMC. Bayesian Analysis. doi: 10.1214/20-BA1221 arXiv: 1903.08008\n\n[BDA3]: Gelman, A., Carlin, J. B., Stern, H. S., Dunson, D. B., Vehtari, A., & Rubin, D. B. (2013). Bayesian data analysis. CRC press.\n\n\n\n\n\n","category":"type"},{"location":"api/diagnostics/#mcse","page":"Diagnostics","title":"Monte Carlo standard error","text":"","category":"section"},{"location":"api/diagnostics/#MCMCDiagnosticTools.mcse","page":"Diagnostics","title":"MCMCDiagnosticTools.mcse","text":"mcse(data::InferenceData; kwargs...) -> Dataset\nmcse(data::Dataset; kwargs...) -> Dataset\n\nCalculate the Monte Carlo standard error (MCSE) for each parameter in the data.\n\nFor more details and a description of the kwargs, see MCMCDiagnosticTools.mcse.\n\n\n\n\n\nmcse(samples::AbstractArray{<:Union{Missing,Real}}; kind=Statistics.mean, kwargs...)\n\nEstimate the Monte Carlo standard errors (MCSE) of the estimator kind applied to samples of shape (draws, [chains[, parameters...]]).\n\nSee also: ess\n\nKinds of MCSE estimates\n\nThe estimator whose MCSE should be estimated is specified with kind. kind must accept a vector of the same eltype as samples and return a real estimate.\n\nFor the following estimators, the effective sample size ess and an estimate of the asymptotic variance are used to compute the MCSE, and kwargs are forwarded to ess:\n\nStatistics.mean\nStatistics.median\nStatistics.std\nBase.Fix2(Statistics.quantile, p::Real)\n\nFor other estimators, the subsampling bootstrap method (SBM)[FlegalJones2011][Flegal2012] is used as a fallback, and the only accepted kwargs are batch_size, which indicates the size of the overlapping batches used to estimate the MCSE, defaulting to floor(Int, sqrt(draws * chains)). Note that SBM tends to underestimate the MCSE, especially for highly autocorrelated chains. One should verify that autocorrelation is low by checking the bulk- and tail-ESS values.\n\n[FlegalJones2011]: Flegal JM, Jones GL. (2011) Implementing MCMC: estimating with confidence.                 Handbook of Markov Chain Monte Carlo. pp. 175-97.                 pdf\n\n[Flegal2012]: Flegal JM. (2012) Applicability of subsampling bootstrap methods in Markov chain Monte Carlo.            Monte Carlo and Quasi-Monte Carlo Methods 2010. pp. 363-72.            doi: 10.1007/978-3-642-27440-4_18\n\n\n\n\n\n","category":"function"},{"location":"api/diagnostics/#rstar","page":"Diagnostics","title":"R^* diagnostic","text":"","category":"section"},{"location":"api/diagnostics/#MCMCDiagnosticTools.rstar","page":"Diagnostics","title":"MCMCDiagnosticTools.rstar","text":"rstar(\n    rng::Random.AbstractRNG=Random.default_rng(),\n    classifier,\n    data::Union{InferenceData,Dataset};\n    kwargs...,\n)\n\nCalculate the R^* diagnostic for the data.\n\nFor a description of the classifier and kwargs, see MCMCDiagnosticTools.rstar.\n\n\n\n\n\nrstar(\n    rng::Random.AbstractRNG=Random.default_rng(),\n    classifier,\n    samples,\n    chain_indices::AbstractVector{Int};\n    subset::Real=0.7,\n    split_chains::Int=2,\n    verbosity::Int=0,\n)\n\nCompute the R^* convergence statistic of the table samples with the classifier.\n\nsamples must be either an AbstractMatrix, an AbstractVector, or a table (i.e. implements the Tables.jl interface) whose rows are draws and whose columns are parameters.\n\nchain_indices indicates the chain ids of each row of samples.\n\nThis method supports ragged chains, i.e. chains of nonequal lengths.\n\n\n\n\n\nrstar(\n    rng::Random.AbstractRNG=Random.default_rng(),\n    classifier,\n    samples::AbstractArray{<:Real};\n    subset::Real=0.7,\n    split_chains::Int=2,\n    verbosity::Int=0,\n)\n\nCompute the R^* convergence statistic of the samples with the classifier.\n\nsamples is an array of draws with the shape (draws, [chains[, parameters...]]).`\n\nThis implementation is an adaption of algorithms 1 and 2 described by Lambert and Vehtari.\n\nThe classifier has to be a supervised classifier of the MLJ framework (see the MLJ documentation for a list of supported models). It is trained with a subset of the samples from each chain. Each chain is split into split_chains separate chains to additionally check for within-chain convergence. The training of the classifier can be inspected by adjusting the verbosity level.\n\nIf the classifier is deterministic, i.e., if it predicts a class, the value of the R^* statistic is returned (algorithm 1). If the classifier is probabilistic, i.e., if it outputs probabilities of classes, the scaled Poisson-binomial distribution of the R^* statistic is returned (algorithm 2).\n\nnote: Note\nThe correctness of the statistic depends on the convergence of the classifier used internally in the statistic.\n\nExamples\n\njulia> using MLJBase, MLJIteration, EvoTrees, Statistics, StatisticalMeasures\n\njulia> samples = fill(4.0, 100, 3, 2);\n\nOne can compute the distribution of the R^* statistic (algorithm 2) with a probabilistic classifier. For instance, we can use a gradient-boosted trees model with nrounds = 100 sequentially stacked trees and learning rate eta = 0.05:\n\njulia> model = EvoTreeClassifier(; nrounds=100, eta=0.05);\n\njulia> distribution = rstar(model, samples);\n\njulia> round(mean(distribution); digits=2)\n1.0f0\n\nNote, however, that it is recommended to determine nrounds based on early-stopping. With the MLJ framework, this can be achieved in the following way (see the MLJ documentation for additional explanations):\n\njulia> model = IteratedModel(;\n           model=EvoTreeClassifier(; eta=0.05),\n           iteration_parameter=:nrounds,\n           resampling=Holdout(),\n           measures=log_loss,\n           controls=[Step(5), Patience(2), NumberLimit(100)],\n           retrain=true,\n       );\n\njulia> distribution = rstar(model, samples);\n\njulia> round(mean(distribution); digits=2)\n1.0f0\n\nFor deterministic classifiers, a single R^* statistic (algorithm 1) is returned. Deterministic classifiers can also be derived from probabilistic classifiers by e.g. predicting the mode. In MLJ this corresponds to a pipeline of models.\n\njulia> evotree_deterministic = Pipeline(model; operation=predict_mode);\n\njulia> value = rstar(evotree_deterministic, samples);\n\njulia> round(value; digits=2)\n1.0\n\nReferences\n\nLambert, B., & Vehtari, A. (2020). R^*: A robust MCMC convergence diagnostic with uncertainty using decision tree classifiers.\n\n\n\n\n\n","category":"function"},{"location":"api/#api","page":"API Overview","title":"API Overview","text":"","category":"section"},{"location":"api/","page":"API Overview","title":"API Overview","text":"Pages = [\"data.md\", \"dataset.md\", \"diagnostics.md\", \"inference_data.md\", \"stats.md\"]\nDepth = 1","category":"page"},{"location":"creating_custom_plots/#Creating-custom-plots","page":"Creating custom plots","title":"Creating custom plots","text":"","category":"section"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"While ArviZ includes many plotting functions for visualizing the data stored in InferenceData objects, you will often need to construct custom plots, or you may want to tweak some of our plots in your favorite plotting package.","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"In this tutorial, we will show you a few useful techniques you can use to construct these plots using Julia’s plotting packages. For demonstration purposes, we’ll use Makie.jl and AlgebraOfGraphics.jl, which can consume Dataset objects since they implement the Tables interface. However, we could just as easily have used StatsPlots.jl.","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"using ArviZ, ArviZExampleData, DimensionalData, DataFrames, Statistics, AlgebraOfGraphics, CairoMakie\nusing AlgebraOfGraphics: density\nset_aog_theme!()","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"We’ll start by loading some draws from an implementation of the non-centered parameterization of the 8 schools model. In this parameterization, the model has some sampling issues.","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"idata = load_example_data(\"centered_eight\")","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"<div>InferenceData<details>\n<summary>posterior</summary>\n<pre><span class=\"sgr90\">┌ </span><span class=\"sgr38_5\" style=\"color:#ff875f\">500</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">8</span> Dataset<span class=\"sgr90\"> ┐</span>\n<span class=\"sgr90\">├─────────────────┴───────────────────────────────────────────── dims ┐</span>\n  <span class=\"sgr38_5\" style=\"color:#ff875f\">↓ draw</span> Sampled{Int64} <span class=\"sgr38_5\" style=\"color:#ff875f\">[0, …, 499]</span> <span class=\"sgr38_5\" style=\"color:#808080\">ForwardOrdered</span> <span class=\"sgr38_5\" style=\"color:#808080\">Irregular</span> <span class=\"sgr38_5\" style=\"color:#808080\">Points</span>,\n  <span class=\"sgr38_5\" style=\"color:#0087d7\">→ chain</span> Sampled{Int64} <span class=\"sgr38_5\" style=\"color:#0087d7\">[0, …, 3]</span> <span class=\"sgr38_5\" style=\"color:#808080\">ForwardOrdered</span> <span class=\"sgr38_5\" style=\"color:#808080\">Irregular</span> <span class=\"sgr38_5\" style=\"color:#808080\">Points</span>,\n  <span class=\"sgr38_5\" style=\"color:#5fd7ff\">↗ school</span> Categorical{String} <span class=\"sgr38_5\" style=\"color:#5fd7ff\">[&quot;Choate&quot;, …, &quot;Mt. Hermon&quot;]</span> <span class=\"sgr38_5\" style=\"color:#808080\">Unordered</span>\n<span class=\"sgr90\">├───────────────────────────────────────────────────────────── layers ┤</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :mu   </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">500</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :theta</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#5fd7ff\">school</span>, <span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#5fd7ff\">8</span>×<span class=\"sgr38_5\" style=\"color:#ff875f\">500</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :tau  </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">500</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr90\">├─────────────────────────────────────────────────────────── metadata ┤</span>\n  Dict{String, Any} with 6 entries:\n  &quot;created_at&quot; =&gt; &quot;2025-01-19T14:32:33.071271+00:00&quot;\n  &quot;inference_library_version&quot; =&gt; &quot;5.20.0&quot;\n  &quot;sampling_time&quot; =&gt; 3.15909\n  &quot;tuning_steps&quot; =&gt; 1000\n  &quot;arviz_version&quot; =&gt; &quot;0.20.0&quot;\n  &quot;inference_library&quot; =&gt; &quot;pymc&quot;\n</pre></details>\n<details>\n<summary>posterior_predictive</summary>\n<pre><span class=\"sgr90\">┌ </span><span class=\"sgr38_5\" style=\"color:#ff875f\">8</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">500</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">4</span> Dataset<span class=\"sgr90\"> ┐</span>\n<span class=\"sgr90\">├─────────────────┴────────────────────────────────────────────── dims ┐</span>\n  <span class=\"sgr38_5\" style=\"color:#ff875f\">↓ school</span> Categorical{String} <span class=\"sgr38_5\" style=\"color:#ff875f\">[&quot;Choate&quot;, …, &quot;Mt. Hermon&quot;]</span> <span class=\"sgr38_5\" style=\"color:#808080\">Unordered</span>,\n  <span class=\"sgr38_5\" style=\"color:#0087d7\">→ draw</span> Sampled{Int64} <span class=\"sgr38_5\" style=\"color:#0087d7\">[0, …, 499]</span> <span class=\"sgr38_5\" style=\"color:#808080\">ForwardOrdered</span> <span class=\"sgr38_5\" style=\"color:#808080\">Irregular</span> <span class=\"sgr38_5\" style=\"color:#808080\">Points</span>,\n  <span class=\"sgr38_5\" style=\"color:#5fd7ff\">↗ chain</span> Sampled{Int64} <span class=\"sgr38_5\" style=\"color:#5fd7ff\">[0, …, 3]</span> <span class=\"sgr38_5\" style=\"color:#808080\">ForwardOrdered</span> <span class=\"sgr38_5\" style=\"color:#808080\">Irregular</span> <span class=\"sgr38_5\" style=\"color:#808080\">Points</span>\n<span class=\"sgr90\">├────────────────────────────────────────────────────────────── layers ┤</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :obs</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">school</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">draw</span>, <span class=\"sgr38_5\" style=\"color:#5fd7ff\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">8</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">500</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">4</span>\n<span class=\"sgr90\">├──────────────────────────────────────────────────────────── metadata ┤</span>\n  Dict{String, Any} with 4 entries:\n  &quot;created_at&quot; =&gt; &quot;2025-01-19T14:32:33.992006+00:00&quot;\n  &quot;inference_library_version&quot; =&gt; &quot;5.20.0&quot;\n  &quot;arviz_version&quot; =&gt; &quot;0.20.0&quot;\n  &quot;inference_library&quot; =&gt; &quot;pymc&quot;\n</pre></details>\n<details>\n<summary>log_likelihood</summary>\n<pre><span class=\"sgr90\">┌ </span><span class=\"sgr38_5\" style=\"color:#ff875f\">8</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">500</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">4</span> Dataset<span class=\"sgr90\"> ┐</span>\n<span class=\"sgr90\">├─────────────────┴────────────────────────────────────────────── dims ┐</span>\n  <span class=\"sgr38_5\" style=\"color:#ff875f\">↓ school</span> Categorical{String} <span class=\"sgr38_5\" style=\"color:#ff875f\">[&quot;Choate&quot;, …, &quot;Mt. Hermon&quot;]</span> <span class=\"sgr38_5\" style=\"color:#808080\">Unordered</span>,\n  <span class=\"sgr38_5\" style=\"color:#0087d7\">→ draw</span> Sampled{Int64} <span class=\"sgr38_5\" style=\"color:#0087d7\">[0, …, 499]</span> <span class=\"sgr38_5\" style=\"color:#808080\">ForwardOrdered</span> <span class=\"sgr38_5\" style=\"color:#808080\">Irregular</span> <span class=\"sgr38_5\" style=\"color:#808080\">Points</span>,\n  <span class=\"sgr38_5\" style=\"color:#5fd7ff\">↗ chain</span> Sampled{Int64} <span class=\"sgr38_5\" style=\"color:#5fd7ff\">[0, …, 3]</span> <span class=\"sgr38_5\" style=\"color:#808080\">ForwardOrdered</span> <span class=\"sgr38_5\" style=\"color:#808080\">Irregular</span> <span class=\"sgr38_5\" style=\"color:#808080\">Points</span>\n<span class=\"sgr90\">├────────────────────────────────────────────────────────────── layers ┤</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :obs</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">school</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">draw</span>, <span class=\"sgr38_5\" style=\"color:#5fd7ff\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">8</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">500</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">4</span>\n<span class=\"sgr90\">├──────────────────────────────────────────────────────────── metadata ┤</span>\n  Dict{String, Any} with 4 entries:\n  &quot;created_at&quot; =&gt; &quot;2025-01-19T14:32:33.869112+00:00&quot;\n  &quot;inference_library_version&quot; =&gt; &quot;5.20.0&quot;\n  &quot;arviz_version&quot; =&gt; &quot;0.20.0&quot;\n  &quot;inference_library&quot; =&gt; &quot;pymc&quot;\n</pre></details>\n<details>\n<summary>sample_stats</summary>\n<pre><span class=\"sgr90\">┌ </span><span class=\"sgr38_5\" style=\"color:#ff875f\">500</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span> Dataset<span class=\"sgr90\"> ┐</span>\n<span class=\"sgr90\">├───────────────┴──────────────────────────────────────────────────────── dims ┐</span>\n  <span class=\"sgr38_5\" style=\"color:#ff875f\">↓ draw</span> Sampled{Int64} <span class=\"sgr38_5\" style=\"color:#ff875f\">[0, …, 499]</span> <span class=\"sgr38_5\" style=\"color:#808080\">ForwardOrdered</span> <span class=\"sgr38_5\" style=\"color:#808080\">Irregular</span> <span class=\"sgr38_5\" style=\"color:#808080\">Points</span>,\n  <span class=\"sgr38_5\" style=\"color:#0087d7\">→ chain</span> Sampled{Int64} <span class=\"sgr38_5\" style=\"color:#0087d7\">[0, …, 3]</span> <span class=\"sgr38_5\" style=\"color:#808080\">ForwardOrdered</span> <span class=\"sgr38_5\" style=\"color:#808080\">Irregular</span> <span class=\"sgr38_5\" style=\"color:#808080\">Points</span>\n<span class=\"sgr90\">├────────────────────────────────────────────────────────────────────── layers ┤</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :step_size            </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">500</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :reached_max_treedepth</span><span class=\"sgr90\"> eltype: </span>Bool<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">500</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :perf_counter_start   </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">500</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :energy_error         </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">500</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :perf_counter_diff    </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">500</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :tree_depth           </span><span class=\"sgr90\"> eltype: </span>Int64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">500</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :process_time_diff    </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">500</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :n_steps              </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">500</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :max_energy_error     </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">500</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :step_size_bar        </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">500</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :lp                   </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">500</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :index_in_trajectory  </span><span class=\"sgr90\"> eltype: </span>Int64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">500</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :acceptance_rate      </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">500</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :smallest_eigval      </span><span class=\"sgr90\"> eltype: </span>Union{Missing, Float64}<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">500</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :energy               </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">500</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :diverging            </span><span class=\"sgr90\"> eltype: </span>Bool<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">500</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :largest_eigval       </span><span class=\"sgr90\"> eltype: </span>Union{Missing, Float64}<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">draw</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">500</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">4</span>\n<span class=\"sgr90\">├──────────────────────────────────────────────────────────────────── metadata ┤</span>\n  Dict{String, Any} with 6 entries:\n  &quot;created_at&quot; =&gt; &quot;2025-01-19T14:32:33.083969+00:00&quot;\n  &quot;inference_library_version&quot; =&gt; &quot;5.20.0&quot;\n  &quot;sampling_time&quot; =&gt; 3.15909\n  &quot;tuning_steps&quot; =&gt; 1000\n  &quot;arviz_version&quot; =&gt; &quot;0.20.0&quot;\n  &quot;inference_library&quot; =&gt; &quot;pymc&quot;\n</pre></details>\n<details>\n<summary>prior</summary>\n<pre><span class=\"sgr90\">┌ </span><span class=\"sgr38_5\" style=\"color:#ff875f\">8</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">500</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">1</span> Dataset<span class=\"sgr90\"> ┐</span>\n<span class=\"sgr90\">├─────────────────┴────────────────────────────────────────────── dims ┐</span>\n  <span class=\"sgr38_5\" style=\"color:#ff875f\">↓ school</span> Categorical{String} <span class=\"sgr38_5\" style=\"color:#ff875f\">[&quot;Choate&quot;, …, &quot;Mt. Hermon&quot;]</span> <span class=\"sgr38_5\" style=\"color:#808080\">Unordered</span>,\n  <span class=\"sgr38_5\" style=\"color:#0087d7\">→ draw</span> Sampled{Int64} <span class=\"sgr38_5\" style=\"color:#0087d7\">[0, …, 499]</span> <span class=\"sgr38_5\" style=\"color:#808080\">ForwardOrdered</span> <span class=\"sgr38_5\" style=\"color:#808080\">Irregular</span> <span class=\"sgr38_5\" style=\"color:#808080\">Points</span>,\n  <span class=\"sgr38_5\" style=\"color:#5fd7ff\">↗ chain</span> Sampled{Int64} <span class=\"sgr38_5\" style=\"color:#5fd7ff\">[0]</span> <span class=\"sgr38_5\" style=\"color:#808080\">ForwardOrdered</span> <span class=\"sgr38_5\" style=\"color:#808080\">Irregular</span> <span class=\"sgr38_5\" style=\"color:#808080\">Points</span>\n<span class=\"sgr90\">├────────────────────────────────────────────────────────────── layers ┤</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :theta</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">school</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">draw</span>, <span class=\"sgr38_5\" style=\"color:#5fd7ff\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">8</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">500</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">1</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :tau  </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#0087d7\">draw</span>, <span class=\"sgr38_5\" style=\"color:#5fd7ff\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#0087d7\">500</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">1</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :mu   </span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#0087d7\">draw</span>, <span class=\"sgr38_5\" style=\"color:#5fd7ff\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#0087d7\">500</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">1</span>\n<span class=\"sgr90\">├──────────────────────────────────────────────────────────── metadata ┤</span>\n  Dict{String, Any} with 4 entries:\n  &quot;created_at&quot; =&gt; &quot;2025-01-19T14:32:29.212688+00:00&quot;\n  &quot;inference_library_version&quot; =&gt; &quot;5.20.0&quot;\n  &quot;arviz_version&quot; =&gt; &quot;0.20.0&quot;\n  &quot;inference_library&quot; =&gt; &quot;pymc&quot;\n</pre></details>\n<details>\n<summary>prior_predictive</summary>\n<pre><span class=\"sgr90\">┌ </span><span class=\"sgr38_5\" style=\"color:#ff875f\">8</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">500</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">1</span> Dataset<span class=\"sgr90\"> ┐</span>\n<span class=\"sgr90\">├─────────────────┴────────────────────────────────────────────── dims ┐</span>\n  <span class=\"sgr38_5\" style=\"color:#ff875f\">↓ school</span> Categorical{String} <span class=\"sgr38_5\" style=\"color:#ff875f\">[&quot;Choate&quot;, …, &quot;Mt. Hermon&quot;]</span> <span class=\"sgr38_5\" style=\"color:#808080\">Unordered</span>,\n  <span class=\"sgr38_5\" style=\"color:#0087d7\">→ draw</span> Sampled{Int64} <span class=\"sgr38_5\" style=\"color:#0087d7\">[0, …, 499]</span> <span class=\"sgr38_5\" style=\"color:#808080\">ForwardOrdered</span> <span class=\"sgr38_5\" style=\"color:#808080\">Irregular</span> <span class=\"sgr38_5\" style=\"color:#808080\">Points</span>,\n  <span class=\"sgr38_5\" style=\"color:#5fd7ff\">↗ chain</span> Sampled{Int64} <span class=\"sgr38_5\" style=\"color:#5fd7ff\">[0]</span> <span class=\"sgr38_5\" style=\"color:#808080\">ForwardOrdered</span> <span class=\"sgr38_5\" style=\"color:#808080\">Irregular</span> <span class=\"sgr38_5\" style=\"color:#808080\">Points</span>\n<span class=\"sgr90\">├────────────────────────────────────────────────────────────── layers ┤</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :obs</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">school</span>, <span class=\"sgr38_5\" style=\"color:#0087d7\">draw</span>, <span class=\"sgr38_5\" style=\"color:#5fd7ff\">chain</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">8</span>×<span class=\"sgr38_5\" style=\"color:#0087d7\">500</span>×<span class=\"sgr38_5\" style=\"color:#5fd7ff\">1</span>\n<span class=\"sgr90\">├──────────────────────────────────────────────────────────── metadata ┤</span>\n  Dict{String, Any} with 4 entries:\n  &quot;created_at&quot; =&gt; &quot;2025-01-19T14:32:29.215699+00:00&quot;\n  &quot;inference_library_version&quot; =&gt; &quot;5.20.0&quot;\n  &quot;arviz_version&quot; =&gt; &quot;0.20.0&quot;\n  &quot;inference_library&quot; =&gt; &quot;pymc&quot;\n</pre></details>\n<details>\n<summary>observed_data</summary>\n<pre><span class=\"sgr90\">┌ </span><span class=\"sgr38_5\" style=\"color:#ff875f\">8-element </span>Dataset<span class=\"sgr90\"> ┐</span>\n<span class=\"sgr90\">├───────────────────┴──────────────────────────────────────────── dims ┐</span>\n  <span class=\"sgr38_5\" style=\"color:#ff875f\">↓ school</span> Categorical{String} <span class=\"sgr38_5\" style=\"color:#ff875f\">[&quot;Choate&quot;, …, &quot;Mt. Hermon&quot;]</span> <span class=\"sgr38_5\" style=\"color:#808080\">Unordered</span>\n<span class=\"sgr90\">├────────────────────────────────────────────────────────────── layers ┤</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :obs</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">school</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">8</span>\n<span class=\"sgr90\">├──────────────────────────────────────────────────────────── metadata ┤</span>\n  Dict{String, Any} with 4 entries:\n  &quot;created_at&quot; =&gt; &quot;2025-01-19T14:32:29.216855+00:00&quot;\n  &quot;inference_library_version&quot; =&gt; &quot;5.20.0&quot;\n  &quot;arviz_version&quot; =&gt; &quot;0.20.0&quot;\n  &quot;inference_library&quot; =&gt; &quot;pymc&quot;\n</pre></details>\n<details>\n<summary>constant_data</summary>\n<pre><span class=\"sgr90\">┌ </span><span class=\"sgr38_5\" style=\"color:#ff875f\">8-element </span>Dataset<span class=\"sgr90\"> ┐</span>\n<span class=\"sgr90\">├───────────────────┴──────────────────────────────────────────── dims ┐</span>\n  <span class=\"sgr38_5\" style=\"color:#ff875f\">↓ school</span> Categorical{String} <span class=\"sgr38_5\" style=\"color:#ff875f\">[&quot;Choate&quot;, …, &quot;Mt. Hermon&quot;]</span> <span class=\"sgr38_5\" style=\"color:#808080\">Unordered</span>\n<span class=\"sgr90\">├────────────────────────────────────────────────────────────── layers ┤</span>\n<span class=\"sgr38_5\" style=\"color:#00afaf\">  :sigma</span><span class=\"sgr90\"> eltype: </span>Float64<span class=\"sgr90\"> dims: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">school</span><span class=\"sgr90\"> size: </span><span class=\"sgr38_5\" style=\"color:#ff875f\">8</span>\n<span class=\"sgr90\">├──────────────────────────────────────────────────────────── metadata ┤</span>\n  Dict{String, Any} with 4 entries:\n  &quot;created_at&quot; =&gt; &quot;2025-01-19T14:32:29.217914+00:00&quot;\n  &quot;inference_library_version&quot; =&gt; &quot;5.20.0&quot;\n  &quot;arviz_version&quot; =&gt; &quot;0.20.0&quot;\n  &quot;inference_library&quot; =&gt; &quot;pymc&quot;\n</pre></details>\n</div>","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"idata.posterior","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"┌ 500×4×8 Dataset ┐\n├─────────────────┴───────────────────────────────────────────── dims ┐\n  ↓ draw Sampled{Int64} [0, …, 499] ForwardOrdered Irregular Points,\n  → chain Sampled{Int64} [0, …, 3] ForwardOrdered Irregular Points,\n  ↗ school Categorical{String} [\"Choate\", …, \"Mt. Hermon\"] Unordered\n├───────────────────────────────────────────────────────────── layers ┤\n  :mu    eltype: Float64 dims: draw, chain size: 500×4\n  :theta eltype: Float64 dims: school, draw, chain size: 8×500×4\n  :tau   eltype: Float64 dims: draw, chain size: 500×4\n├─────────────────────────────────────────────────────────── metadata ┤\n  Dict{String, Any} with 6 entries:\n  \"created_at\"                => \"2025-01-19T14:32:33.071271+00:00\"\n  \"inference_library_version\" => \"5.20.0\"\n  \"sampling_time\"             => 3.15909\n  \"tuning_steps\"              => 1000\n  \"arviz_version\"             => \"0.20.0\"\n  \"inference_library\"         => \"pymc\"","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"The plotting functions we’ll be using interact with a tabular view of a Dataset. Let’s see what that view looks like for a Dataset:","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"df = DataFrame(idata.posterior)","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"<div><div style = \"float: left;\"><span>16000×6 DataFrame</span></div><div style = \"float: right;\"><span style = \"font-style: italic;\">15975 rows omitted</span></div><div style = \"clear: both;\"></div></div><div class = \"data-frame\" style = \"overflow-x: scroll;\">\n\n[TABLE]\n\n</div>","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"The tabular view includes dimensions and variables as columns.","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"When variables with different dimensions are flattened into a tabular form, there’s always some duplication of values. As a simple case, note that chain, draw, and school all have repeated values in the above table.","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"In this case, theta has the school dimension, but tau doesn’t, so the values of tau will be repeated in the table for each value of school.","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"df[df.school .== Ref(\"Choate\"), :].tau == df[df.school .== Ref(\"Deerfield\"), :].tau","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"true","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"In our first example, this will be important.","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"Here, let’s construct a trace plot. Besides idata, all functions and types in the following cell are defined in AlgebraOfGraphics or Makie:","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"data(...) indicates that the wrapped object implements the Tables interface\nmapping indicates how the data should be used. The symbols are all column names in the table, which for us are our variable names and dimensions.\nvisual specifies how the data should be converted to a plot.\nLines is a plot type defined in Makie.\ndraw takes this combination and plots it.","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"draw(\n    data(idata.posterior.mu) *\n    mapping(:draw, :mu; color=:chain => nonnumeric) *\n    visual(Lines; alpha=0.8),\n)","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"(Image: )","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"Note the line idata.posterior.mu. If we had just used idata.posterior, the plot would have looked more-or-less the same, but there would be artifacts due to mu being copied many times. By selecting mu directly, all other dimensions are discarded, so each value of mu appears in the plot exactly once.","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"When examining an MCMC trace plot, we want to see a “fuzzy caterpillar”. Instead we see a few places where the Markov chains froze. We can do the same for theta as well, but it’s more useful here to separate these draws by school.","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"draw(\n    data(idata.posterior) *\n    mapping(:draw, :theta; layout=:school, color=:chain => nonnumeric) *\n    visual(Lines; alpha=0.8),\n)","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"(Image: )","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"Suppose we want to compare tau with theta for two different schools. To do so, we use InferenceDatas indexing syntax to subset the data.","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"draw(\n    data(idata[:posterior, school=At([\"Choate\", \"Deerfield\"])]) *\n    mapping(:theta, :tau; color=:school) *\n    density() *\n    visual(Contour; levels=10),\n)","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"(Image: )","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"We can also compare the density plots constructed from each chain for different schools.","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"draw(\n    data(idata.posterior) *\n    mapping(:theta; layout=:school, color=:chain => nonnumeric) *\n    density(),\n)","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"(Image: )","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"If we want to compare many schools in a single plot, an ECDF plot is more convenient.","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"draw(\n    data(idata.posterior) * mapping(:theta; color=:school => nonnumeric) * visual(ECDFPlot);\n    axis=(; ylabel=\"probability\"),\n)","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"(Image: )","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"So far we’ve just plotted data from one group, but we often want to combine data from multiple groups in one plot. The simplest way to do this is to create the plot out of multiple layers. Here we use this approach to plot the observations over the posterior predictive distribution.","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"draw(\n    (data(idata.posterior_predictive) * mapping(:obs; layout=:school) * density()) +\n    (data(idata.observed_data) * mapping(:obs, :obs => zero => \"\"; layout=:school)),\n)","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"(Image: )","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"Another option is to combine the groups into a single dataset.","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"Here we compare the prior and posterior. Since the prior has 1 chain and the posterior has 4 chains, if we were to combine them into a table, the structure would need to be ragged. This is not currently supported.","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"We can then either plot the two distributions separately as we did before, or we can compare a single chain from each group. This is what we’ll do here. To concatenate the two groups, we introduce a new named dimension using DimensionalData.Dim.","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"draw(\n    data(\n        cat(\n            idata.posterior[chain=[1]], idata.prior; dims=Dim{:group}([:posterior, :prior])\n        )[:mu],\n    ) *\n    mapping(:mu; color=:group) *\n    histogram(; bins=20) *\n    visual(; alpha=0.8);\n    axis=(; ylabel=\"probability\"),\n)","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"(Image: )","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"From the trace plots, we suspected the geometry of this posterior was bad. Let’s highlight divergent transitions. To do so, we merge posterior and samplestats, which can do with merge since they share no common variable names.","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"draw(\n    data(merge(idata.posterior, idata.sample_stats)) * mapping(\n        :theta,\n        :tau;\n        layout=:school,\n        color=:diverging,\n        markersize=:diverging => (d -> d ? 5 : 2),\n    ),\n)","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"(Image: )","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"When we try building more complex plots, we may need to build new Datasets from our existing ones.","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"One example of this is the corner plot. To build this plot, we need to make a copy of theta with a copy of the school dimension.","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"theta = idata.posterior.theta[school=1:4]\ntheta2 = rebuild(set(theta; school=:school2); name=:theta2)\nplot_data = Dataset(theta, theta2, idata.sample_stats.diverging)\ndraw(\n    data(plot_data) * mapping(\n        :theta,\n        :theta2 => \"theta\";\n        col=:school,\n        row=:school2,\n        color=:diverging,\n        markersize=:diverging => (d -> d ? 3 : 1),\n    );\n    figure=(; figsize=(5, 5)),\n    axis=(; aspect=1),\n)","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"(Image: )","category":"page"},{"location":"creating_custom_plots/#Environment","page":"Creating custom plots","title":"Environment","text":"","category":"section"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"using Pkg\nPkg.status()","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"Status `~/work/ArviZ.jl/ArviZ.jl/docs/Project.toml`\n⌃ [cbdf2221] AlgebraOfGraphics v0.11.4\n  [131c737c] ArviZ v0.12.3 `~/work/ArviZ.jl/ArviZ.jl`\n  [2f96bb34] ArviZExampleData v0.2.0\n  [4a6e88f0] ArviZPythonPlots v0.1.9\n  [13f3f980] CairoMakie v0.15.6\n  [a93c6f00] DataFrames v1.7.0\n  [0703355e] DimensionalData v0.29.23\n  [31c24e10] Distributions v0.25.120\n  [e30172f5] Documenter v1.14.1\n  [f6006082] EvoTrees v0.17.4\n  [b5cf5a8d] InferenceObjects v0.4.12\n  [be115224] MCMCDiagnosticTools v0.3.15\n  [a7f614a8] MLJBase v1.8.2\n  [614be32b] MLJIteration v0.6.3\n  [ce719bf2] PSIS v0.9.8\n  [7f36be82] PosteriorStats v0.2.8\n  [c1514b29] StanSample v7.10.2\n  [a19d573c] StatisticalMeasures v0.2.1\n  [10745b16] Statistics v1.11.1\n  [2913bbd2] StatsBase v0.34.6\n  [fce5fe82] Turing v0.40.2\n  [f43a241f] Downloads v1.6.0\n  [37e2e46d] LinearAlgebra v1.11.0\nInfo Packages marked with ⌃ have new versions available and may be upgradable.","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"versioninfo()","category":"page"},{"location":"creating_custom_plots/","page":"Creating custom plots","title":"Creating custom plots","text":"Julia Version 1.11.6\nCommit 9615af0f269 (2025-07-09 12:58 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 4 × AMD EPYC 7763 64-Core Processor\n  WORD_SIZE: 64\n  LLVM: libLLVM-16.0.6 (ORCJIT, znver3)\nThreads: 2 default, 0 interactive, 1 GC (on 4 virtual cores)\nEnvironment:\n  JULIA_PKG_SERVER_REGISTRY_PREFERENCE = eager\n  JULIA_PROJECT = @.\n  JULIA_NUM_THREADS = 2\n  JULIA_LOAD_PATH = @:@stdlib","category":"page"},{"location":"api/stats/#stats-api","page":"Stats","title":"Stats","text":"","category":"section"},{"location":"api/stats/","page":"Stats","title":"Stats","text":"Pages = [\"stats.md\"]","category":"page"},{"location":"api/stats/#Summary-statistics","page":"Stats","title":"Summary statistics","text":"","category":"section"},{"location":"api/stats/#PosteriorStats.SummaryStats","page":"Stats","title":"PosteriorStats.SummaryStats","text":"struct SummaryStats{D, V<:(AbstractVector)}\n\nA container for a column table of values computed by summarize.\n\nThis object implements the Tables and TableTraits column table interfaces. It has a custom show method.\n\nSummaryStats behaves like an OrderedDict of columns, where the columns can be accessed using either Symbols or a 1-based integer index.\n\nname::String: The name of the collection of summary statistics, used as the table title in display.\ndata::Any: The summary statistics for each parameter. It must implement the Tables interface.\nparameter_names::AbstractVector: Names of the parameters\n\nSummaryStats([name::String,] data[, parameter_names])\nSummaryStats(data[, parameter_names]; name::String=\"SummaryStats\")\n\nConstruct a SummaryStats from tabular data with optional stats name and param_names.\n\ndata must not contain a column :parameter, as this is reserved for the parameter names, which are always in the first column.\n\n\n\n\n\n","category":"type"},{"location":"api/stats/#PosteriorStats.default_summary_stats","page":"Stats","title":"PosteriorStats.default_summary_stats","text":"default_summary_stats(focus=Statistics.mean; kwargs...)\n\nCombinatiton of default_stats and default_diagnostics to be used with summarize.\n\n\n\n\n\n","category":"function"},{"location":"api/stats/#PosteriorStats.default_stats","page":"Stats","title":"PosteriorStats.default_stats","text":"default_stats(focus=Statistics.mean; prob_interval=0.94, kwargs...)\n\nDefault statistics to be computed with summarize.\n\nThe value of focus determines the statistics to be returned:\n\nStatistics.mean: mean, std, hdi_3%, hdi_97%\nStatistics.median: median, mad, eti_3%, eti_97%\n\nIf prob_interval is set to a different value than the default, then different HDI and ETI statistics are computed accordingly. hdi refers to the highest-density interval, while eti refers to the equal-tailed interval (i.e. the credible interval computed from symmetric quantiles).\n\nSee also: hdi\n\n\n\n\n\n","category":"function"},{"location":"api/stats/#PosteriorStats.default_diagnostics","page":"Stats","title":"PosteriorStats.default_diagnostics","text":"default_diagnostics(focus=Statistics.mean; kwargs...)\n\nDefault diagnostics to be computed with summarize.\n\nThe value of focus determines the diagnostics to be returned:\n\nStatistics.mean: mcse_mean, mcse_std, ess_tail, ess_bulk, rhat\nStatistics.median: mcse_median, ess_tail, ess_bulk, rhat\n\n\n\n\n\n","category":"function"},{"location":"api/stats/#PosteriorStats.summarize","page":"Stats","title":"PosteriorStats.summarize","text":"summarize(data, stats_funs...; name=\"SummaryStats\", [var_names]) -> SummaryStats\n\nCompute the summary statistics in stats_funs on each param in data.\n\nstats_funs is a collection of functions that reduces a matrix with shape (draws, chains) to a scalar or a collection of scalars. Alternatively, an item in stats_funs may be a Pair of the form name => fun specifying the name to be used for the statistic or of the form (name1, ...) => fun when the function returns a collection. When the function returns a collection, the names in this latter format must be provided.\n\nIf no stats functions are provided, then those specified in default_summary_stats are computed.\n\nvar_names specifies the names of the parameters in data. If not provided, the names are inferred from data.\n\nTo support computing summary statistics from a custom object, overload this method specifying the type of data.\n\nSee also SummaryStats, default_summary_stats, default_stats, default_diagnostics.\n\nExamples\n\nCompute mean, std and the Monte Carlo standard error (MCSE) of the mean estimate:\n\njulia> using Statistics, StatsBase\n\njulia> x = randn(1000, 4, 3) .+ reshape(0:10:20, 1, 1, :);\n\njulia> summarize(x, mean, std, :mcse_mean => sem; name=\"Mean/Std\")\nMean/Std\n       mean    std  mcse_mean\n 1   0.0003  0.989      0.016\n 2  10.02    0.988      0.016\n 3  19.98    0.988      0.016\n\nAvoid recomputing the mean by using mean_and_std, and provide parameter names:\n\njulia> summarize(x, (:mean, :std) => mean_and_std, mad; var_names=[:a, :b, :c])\nSummaryStats\n         mean    std    mad\n a   0.000275  0.989  0.978\n b  10.0       0.988  0.995\n c  20.0       0.988  0.979\n\nNote that when an estimator and its MCSE are both computed, the MCSE is used to determine the number of significant digits that will be displayed.\n\njulia> summarize(x; var_names=[:a, :b, :c])\nSummaryStats\n       mean   std  hdi_3%  hdi_97%  mcse_mean  mcse_std  ess_tail  ess_bulk  r ⋯\n a   0.0003  0.99   -1.92     1.78      0.016     0.012      3567      3663  1 ⋯\n b  10.02    0.99    8.17    11.9       0.016     0.011      3841      3906  1 ⋯\n c  19.98    0.99   18.1     21.9       0.016     0.012      3892      3749  1 ⋯\n                                                                1 column omitted\n\nCompute just the statistics with an 89% HDI on all parameters, and provide the parameter names:\n\njulia> summarize(x, default_stats(; prob_interval=0.89)...; var_names=[:a, :b, :c])\nSummaryStats\n         mean    std  hdi_5.5%  hdi_94.5%\n a   0.000275  0.989     -1.63       1.52\n b  10.0       0.988      8.53      11.6\n c  20.0       0.988     18.5       21.6\n\nCompute the summary stats focusing on Statistics.median:\n\njulia> summarize(x, default_summary_stats(median)...; var_names=[:a, :b, :c])\nSummaryStats\n    median    mad  eti_3%  eti_97%  mcse_median  ess_tail  ess_median  rhat\n a   0.004  0.978   -1.83     1.89        0.020      3567        3336  1.00\n b  10.02   0.995    8.17    11.9         0.023      3841        3787  1.00\n c  19.99   0.979   18.1     21.9         0.020      3892        3829  1.00\n\n\n\n\n\n","category":"function"},{"location":"api/stats/#StatsBase.summarystats","page":"Stats","title":"StatsBase.summarystats","text":"summarystats(data::InferenceData; group=:posterior, kwargs...) -> SummaryStats\nsummarystats(data::Dataset; kwargs...) -> SummaryStats\n\nCompute default summary statistics for the data using PosteriorStats.summarize.\n\n\n\n\n\n","category":"function"},{"location":"api/stats/#General-statistics","page":"Stats","title":"General statistics","text":"","category":"section"},{"location":"api/stats/#PosteriorStats.hdi","page":"Stats","title":"PosteriorStats.hdi","text":"hdi(samples::AbstractArray{<:Real}; prob=0.94) -> (; lower, upper)\n\nEstimate the unimodal highest density interval (HDI) of samples for the probability prob.\n\nThe HDI is the minimum width Bayesian credible interval (BCI). That is, it is the smallest possible interval containing (100*prob)% of the probability mass.[Hyndman1996]\n\nsamples is an array of shape (draws[, chains[, params...]]). If multiple parameters are present, then lower and upper are arrays with the shape (params...,), computed separately for each marginal.\n\nThis implementation uses the algorithm of [ChenShao1999].\n\nnote: Note\nAny default value of prob is arbitrary. The default value of prob=0.94 instead of a more common default like prob=0.95 is chosen to reminder the user of this arbitrariness.\n\n[Hyndman1996]: Rob J. Hyndman (1996) Computing and Graphing Highest Density Regions,             Amer. Stat., 50(2): 120-6.             DOI: 10.1080/00031305.1996.10474359             jstor.\n\n[ChenShao1999]: Ming-Hui Chen & Qi-Man Shao (1999)              Monte Carlo Estimation of Bayesian Credible and HPD Intervals,              J Comput. Graph. Stat., 8:1, 69-92.              DOI: 10.1080/10618600.1999.10474802              jstor.\n\nExamples\n\nHere we calculate the 83% HDI for a normal random variable:\n\njulia> x = randn(2_000);\n\njulia> hdi(x; prob=0.83) |> pairs\npairs(::NamedTuple) with 2 entries:\n  :lower => -1.38266\n  :upper => 1.25982\n\nWe can also calculate the HDI for a 3-dimensional array of samples:\n\njulia> x = randn(1_000, 1, 1) .+ reshape(0:5:10, 1, 1, :);\n\njulia> hdi(x) |> pairs\npairs(::NamedTuple) with 2 entries:\n  :lower => [-1.9674, 3.0326, 8.0326]\n  :upper => [1.90028, 6.90028, 11.9003]\n\n\n\n\n\nhdi(data::InferenceData; kwargs...) -> Dataset\nhdi(data::Dataset; kwargs...) -> Dataset\n\nCalculate the highest density interval (HDI) for each parameter in the data.\n\nFor more details and a description of the kwargs, see PosteriorStats.hdi.\n\n\n\n\n\n","category":"function"},{"location":"api/stats/#PosteriorStats.hdi!","page":"Stats","title":"PosteriorStats.hdi!","text":"hdi!(samples::AbstractArray{<:Real}; prob=0.94) -> (; lower, upper)\n\nA version of hdi that sorts samples in-place while computing the HDI.\n\n\n\n\n\n","category":"function"},{"location":"api/stats/#PosteriorStats.r2_score","page":"Stats","title":"PosteriorStats.r2_score","text":"r2_score(y_true::AbstractVector, y_pred::AbstractArray) -> (; r2, r2_std)\n\nR² for linear Bayesian regression models.[GelmanGoodrich2019]\n\nArguments\n\ny_true: Observed data of length noutputs\ny_pred: Predicted data with size (ndraws[, nchains], noutputs)\n\n[GelmanGoodrich2019]: Andrew Gelman, Ben Goodrich, Jonah Gabry & Aki Vehtari (2019) R-squared for Bayesian Regression Models, The American Statistician, 73:3, 307-9, DOI: 10.1080/00031305.2018.1549100.\n\nExamples\n\njulia> using ArviZExampleData\n\njulia> idata = load_example_data(\"regression1d\");\n\njulia> y_true = idata.observed_data.y;\n\njulia> y_pred = PermutedDimsArray(idata.posterior_predictive.y, (:draw, :chain, :y_dim_0));\n\njulia> r2_score(y_true, y_pred) |> pairs\npairs(::NamedTuple) with 2 entries:\n  :r2     => 0.683197\n  :r2_std => 0.0368838\n\n\n\n\n\nr2_score(idata::InferenceData; y_name, y_pred_name) -> (; r2, r2_std)\n\nCompute R² from idata, automatically formatting the predictions to the correct shape.\n\nKeywords\n\ny_name: Name of observed data variable in idata.observed_data. If not provided, then the only observed data variable is used.\ny_pred_name: Name of posterior predictive variable in idata.posterior_predictive. If not provided, then y_name is used.\n\nSee PosteriorStats.r2_score for more details.\n\nExamples\n\njulia> using ArviZExampleData, PosteriorStats\n\njulia> idata = load_example_data(\"regression10d\");\n\njulia> r2_score(idata) |> pairs\npairs(::NamedTuple) with 2 entries:\n  :r2     => 0.998385\n  :r2_std => 0.000100621\n\n\n\n\n\n","category":"function"},{"location":"api/stats/#Pareto-smoothed-importance-sampling","page":"Stats","title":"Pareto-smoothed importance sampling","text":"","category":"section"},{"location":"api/stats/#PSIS.PSISResult","page":"Stats","title":"PSIS.PSISResult","text":"PSISResult\n\nResult of Pareto-smoothed importance sampling (PSIS) using psis.\n\nProperties\n\nlog_weights: un-normalized Pareto-smoothed log weights\nweights: normalized Pareto-smoothed weights (allocates a copy)\npareto_shape: Pareto k=ξ shape parameter\nnparams: number of parameters in log_weights\nndraws: number of draws in log_weights\nnchains: number of chains in log_weights\nreff: the ratio of the effective sample size of the unsmoothed importance ratios and the actual sample size.\ness: estimated effective sample size of estimate of mean using smoothed importance samples (see ess_is)\ntail_length: length of the upper tail of log_weights that was smoothed\ntail_dist: the generalized Pareto distribution that was fit to the tail of log_weights. Note that the tail weights are scaled to have a maximum of 1, so tail_dist * exp(maximum(log_ratios)) is the corresponding fit directly to the tail of log_ratios.\nnormalized::Bool:indicates whether log_weights are log-normalized along the sample dimensions.\n\nDiagnostic\n\nThe pareto_shape parameter k=ξ of the generalized Pareto distribution tail_dist can be used to diagnose reliability and convergence of estimates using the importance weights VehtariSimpson2021.\n\nif k  frac13, importance sampling is stable, and importance sampling (IS) and PSIS both are reliable.\nif k  frac12, then the importance ratio distributon has finite variance, and the central limit theorem holds. As k approaches the upper bound, IS becomes less reliable, while PSIS still works well but with a higher RMSE.\nif frac12  k  07, then the variance is infinite, and IS can behave quite poorly. However, PSIS works well in this regime.\nif 07  k  1, then it quickly becomes impractical to collect enough importance weights to reliably compute estimates, and importance sampling is not recommended.\nif k  1, then neither the variance nor the mean of the raw importance ratios exists. The convergence rate is close to zero, and bias can be large with practical sample sizes.\n\nSee PSISPlots.paretoshapeplot for a diagnostic plot.\n\nReferences\n\nVehtariSimpson2021 Vehtari et al. JMLR 25:72 (2021).\n\n\n\n\n\n","category":"type"},{"location":"api/stats/#PSIS.ess_is","page":"Stats","title":"PSIS.ess_is","text":"ess_is(weights; reff=1)\n\nEstimate effective sample size (ESS) for importance sampling over the sample dimensions.\n\nGiven normalized weights w_1n, the ESS is estimated using the L2-norm of the weights:\n\nmathrmESS(w_1n) = fracr_mathrmeffsum_i=1^n w_i^2\n\nwhere r_mathrmeff is the relative efficiency of the log_weights.\n\ness_is(result::PSISResult; bad_shape_nan=true)\n\nEstimate ESS for Pareto-smoothed importance sampling.\n\nnote: Note\nESS estimates for Pareto shape values k  07, which are unreliable and misleadingly high, are set to NaN. To avoid this, set bad_shape_nan=false.\n\n\n\n\n\n","category":"function"},{"location":"api/stats/#PSIS.PSISPlots.paretoshapeplot","page":"Stats","title":"PSIS.PSISPlots.paretoshapeplot","text":"paretoshapeplot(values; showlines=false, ...)\nparetoshapeplot!(values; showlines=false, kwargs...)\n\nPlot shape parameters of fitted Pareto tail distributions for diagnosing convergence.\n\nvalues may be either a vector of Pareto shape parameters or a PSIS.PSISResult.\n\nIf showlines==true, horizontal lines indicating relevant Pareto shape thresholds are drawn. See PSIS.PSISResult for an explanation of the thresholds.\n\nAll remaining kwargs are forwarded to the plotting function.\n\nSee psis, PSISResult.\n\nExamples\n\nusing PSIS, Distributions, Plots\nproposal = Normal()\ntarget = TDist(7)\nx = rand(proposal, 1_000, 100)\nlog_ratios = logpdf.(target, x) .- logpdf.(proposal, x)\nresult = psis(log_ratios)\nparetoshapeplot(result)\n\nWe can also plot the Pareto shape parameters directly:\n\nparetoshapeplot(result.pareto_shape)\n\nWe can also use plot directly:\n\nplot(result.pareto_shape; showlines=true)\n\n\n\n\n\n","category":"function"},{"location":"api/stats/#PSIS.psis","page":"Stats","title":"PSIS.psis","text":"psis(log_ratios, reff = 1.0; kwargs...) -> PSISResult\npsis!(log_ratios, reff = 1.0; kwargs...) -> PSISResult\n\nCompute Pareto smoothed importance sampling (PSIS) log weights VehtariSimpson2021.\n\nWhile psis computes smoothed log weights out-of-place, psis! smooths them in-place.\n\nArguments\n\nlog_ratios: an array of logarithms of importance ratios, with size (draws, [chains, [parameters...]]), where chains>1 would be used when chains are generated using Markov chain Monte Carlo.\nreff::Union{Real,AbstractArray}: the ratio(s) of effective sample size of log_ratios and the actual sample size reff = ess/(draws * chains), used to account for autocorrelation, e.g. due to Markov chain Monte Carlo. If an array, it must have the size (parameters...,) to match log_ratios.\n\nKeywords\n\nwarn=true: If true, warning messages are delivered\nnormalize=true: If true, the log-weights will be log-normalized so that exp.(log_weights) sums to 1 along the sample dimensions.\n\nReturns\n\nresult: a PSISResult object containing the results of the Pareto-smoothing.\n\nA warning is raised if the Pareto shape parameter k  07. See PSISResult for details and PSISPlots.paretoshapeplot for a diagnostic plot.\n\nExamples\n\nHere we smooth log importance ratios for importance sampling 30 isotropic Student t-distributed parameters using standard normal distributions as proposals.\n\njulia> using Distributions\n\njulia> proposal, target = Normal(), TDist(7);\n\njulia> x = rand(proposal, 1_000, 1, 30);  # (ndraws, nchains, nparams)\n\njulia> log_ratios = @. logpdf(target, x) - logpdf(proposal, x);\n\njulia> result = psis(log_ratios)\n┌ Warning: 9 parameters had Pareto shape values 0.7 < k ≤ 1. Resulting importance sampling estimates are likely to be unstable.\n└ @ PSIS ~/.julia/packages/PSIS/...\n┌ Warning: 1 parameters had Pareto shape values k > 1. Corresponding importance sampling estimates are likely to be unstable and are unlikely to converge with additional samples.\n└ @ PSIS ~/.julia/packages/PSIS/...\nPSISResult with 1000 draws, 1 chains, and 30 parameters\nPareto shape (k) diagnostic values:\n                        Count       Min. ESS\n (-Inf, 0.5]  good       7 (23.3%)  959\n  (0.5, 0.7]  okay      13 (43.3%)  938\n    (0.7, 1]  bad        9 (30.0%)  ——\n    (1, Inf)  very bad   1 (3.3%)   ——\n\nIf the draws were generated using MCMC, we can compute the relative efficiency using MCMCDiagnosticTools.ess.\n\njulia> using MCMCDiagnosticTools\n\njulia> reff = ess(log_ratios; kind=:basic, split_chains=1, relative=true);\n\njulia> result = psis(log_ratios, reff)\n┌ Warning: 9 parameters had Pareto shape values 0.7 < k ≤ 1. Resulting importance sampling estimates are likely to be unstable.\n└ @ PSIS ~/.julia/packages/PSIS/...\n┌ Warning: 1 parameters had Pareto shape values k > 1. Corresponding importance sampling estimates are likely to be unstable and are unlikely to converge with additional samples.\n└ @ PSIS ~/.julia/packages/PSIS/...\nPSISResult with 1000 draws, 1 chains, and 30 parameters\nPareto shape (k) diagnostic values:\n                        Count       Min. ESS\n (-Inf, 0.5]  good       9 (30.0%)  806\n  (0.5, 0.7]  okay      11 (36.7%)  842\n    (0.7, 1]  bad        9 (30.0%)  ——\n    (1, Inf)  very bad   1 (3.3%)   ——\n\nReferences\n\nVehtariSimpson2021 Vehtari et al. JMLR 25:72 (2021).\n\n\n\n\n\n","category":"function"},{"location":"api/stats/#PSIS.psis!","page":"Stats","title":"PSIS.psis!","text":"psis(log_ratios, reff = 1.0; kwargs...) -> PSISResult\npsis!(log_ratios, reff = 1.0; kwargs...) -> PSISResult\n\nCompute Pareto smoothed importance sampling (PSIS) log weights VehtariSimpson2021.\n\nWhile psis computes smoothed log weights out-of-place, psis! smooths them in-place.\n\nArguments\n\nlog_ratios: an array of logarithms of importance ratios, with size (draws, [chains, [parameters...]]), where chains>1 would be used when chains are generated using Markov chain Monte Carlo.\nreff::Union{Real,AbstractArray}: the ratio(s) of effective sample size of log_ratios and the actual sample size reff = ess/(draws * chains), used to account for autocorrelation, e.g. due to Markov chain Monte Carlo. If an array, it must have the size (parameters...,) to match log_ratios.\n\nKeywords\n\nwarn=true: If true, warning messages are delivered\nnormalize=true: If true, the log-weights will be log-normalized so that exp.(log_weights) sums to 1 along the sample dimensions.\n\nReturns\n\nresult: a PSISResult object containing the results of the Pareto-smoothing.\n\nA warning is raised if the Pareto shape parameter k  07. See PSISResult for details and PSISPlots.paretoshapeplot for a diagnostic plot.\n\nExamples\n\nHere we smooth log importance ratios for importance sampling 30 isotropic Student t-distributed parameters using standard normal distributions as proposals.\n\njulia> using Distributions\n\njulia> proposal, target = Normal(), TDist(7);\n\njulia> x = rand(proposal, 1_000, 1, 30);  # (ndraws, nchains, nparams)\n\njulia> log_ratios = @. logpdf(target, x) - logpdf(proposal, x);\n\njulia> result = psis(log_ratios)\n┌ Warning: 9 parameters had Pareto shape values 0.7 < k ≤ 1. Resulting importance sampling estimates are likely to be unstable.\n└ @ PSIS ~/.julia/packages/PSIS/...\n┌ Warning: 1 parameters had Pareto shape values k > 1. Corresponding importance sampling estimates are likely to be unstable and are unlikely to converge with additional samples.\n└ @ PSIS ~/.julia/packages/PSIS/...\nPSISResult with 1000 draws, 1 chains, and 30 parameters\nPareto shape (k) diagnostic values:\n                        Count       Min. ESS\n (-Inf, 0.5]  good       7 (23.3%)  959\n  (0.5, 0.7]  okay      13 (43.3%)  938\n    (0.7, 1]  bad        9 (30.0%)  ——\n    (1, Inf)  very bad   1 (3.3%)   ——\n\nIf the draws were generated using MCMC, we can compute the relative efficiency using MCMCDiagnosticTools.ess.\n\njulia> using MCMCDiagnosticTools\n\njulia> reff = ess(log_ratios; kind=:basic, split_chains=1, relative=true);\n\njulia> result = psis(log_ratios, reff)\n┌ Warning: 9 parameters had Pareto shape values 0.7 < k ≤ 1. Resulting importance sampling estimates are likely to be unstable.\n└ @ PSIS ~/.julia/packages/PSIS/...\n┌ Warning: 1 parameters had Pareto shape values k > 1. Corresponding importance sampling estimates are likely to be unstable and are unlikely to converge with additional samples.\n└ @ PSIS ~/.julia/packages/PSIS/...\nPSISResult with 1000 draws, 1 chains, and 30 parameters\nPareto shape (k) diagnostic values:\n                        Count       Min. ESS\n (-Inf, 0.5]  good       9 (30.0%)  806\n  (0.5, 0.7]  okay      11 (36.7%)  842\n    (0.7, 1]  bad        9 (30.0%)  ——\n    (1, Inf)  very bad   1 (3.3%)   ——\n\nReferences\n\nVehtariSimpson2021 Vehtari et al. JMLR 25:72 (2021).\n\n\n\n\n\n","category":"function"},{"location":"api/stats/#LOO-and-WAIC","page":"Stats","title":"LOO and WAIC","text":"","category":"section"},{"location":"api/stats/#PosteriorStats.AbstractELPDResult","page":"Stats","title":"PosteriorStats.AbstractELPDResult","text":"abstract type AbstractELPDResult\n\nAn abstract type representing the result of an ELPD computation.\n\nEvery subtype stores estimates of both the expected log predictive density (elpd) and the effective number of parameters p, as well as standard errors and pointwise estimates of each, from which other relevant estimates can be computed.\n\nSubtypes implement the following functions:\n\nelpd_estimates\ninformation_criterion\n\n\n\n\n\n","category":"type"},{"location":"api/stats/#PosteriorStats.PSISLOOResult","page":"Stats","title":"PosteriorStats.PSISLOOResult","text":"Results of Pareto-smoothed importance sampling leave-one-out cross-validation (PSIS-LOO).\n\nSee also: loo, AbstractELPDResult\n\nestimates: Estimates of the expected log pointwise predictive density (ELPD) and effective number of parameters (p)\npointwise: Pointwise estimates\npsis_result: Pareto-smoothed importance sampling (PSIS) results\n\n\n\n\n\n","category":"type"},{"location":"api/stats/#PosteriorStats.WAICResult","page":"Stats","title":"PosteriorStats.WAICResult","text":"Results of computing the widely applicable information criterion (WAIC).\n\nSee also: waic, AbstractELPDResult\n\nestimates: Estimates of the expected log pointwise predictive density (ELPD) and effective number of parameters (p)\npointwise: Pointwise estimates\n\n\n\n\n\n","category":"type"},{"location":"api/stats/#PosteriorStats.elpd_estimates","page":"Stats","title":"PosteriorStats.elpd_estimates","text":"elpd_estimates(result::AbstractELPDResult; pointwise=false) -> (; elpd, elpd_mcse, lpd)\n\nReturn the (E)LPD estimates from the result.\n\n\n\n\n\n","category":"function"},{"location":"api/stats/#PosteriorStats.information_criterion","page":"Stats","title":"PosteriorStats.information_criterion","text":"information_criterion(elpd, scale::Symbol)\n\nCompute the information criterion for the given scale from the elpd estimate.\n\nscale must be one of (:deviance, :log, :negative_log).\n\nSee also: loo, waic\n\n\n\n\n\ninformation_criterion(result::AbstractELPDResult, scale::Symbol; pointwise=false)\n\nCompute information criterion for the given scale from the existing ELPD result.\n\nscale must be one of (:deviance, :log, :negative_log).\n\nIf pointwise=true, then pointwise estimates are returned.\n\n\n\n\n\n","category":"function"},{"location":"api/stats/#PosteriorStats.loo","page":"Stats","title":"PosteriorStats.loo","text":"loo(log_likelihood; reff=nothing, kwargs...) -> PSISLOOResult{<:NamedTuple,<:NamedTuple}\n\nCompute the Pareto-smoothed importance sampling leave-one-out cross-validation (PSIS-LOO). [Vehtari2017][LOOFAQ]\n\nlog_likelihood must be an array of log-likelihood values with shape (chains, draws[, params...]).\n\nKeywords\n\nreff::Union{Real,AbstractArray{<:Real}}: The relative effective sample size(s) of the likelihood values. If an array, it must have the same data dimensions as the corresponding log-likelihood variable. If not provided, then this is estimated using MCMCDiagnosticTools.ess.\nkwargs: Remaining keywords are forwarded to [PSIS.psis].\n\nSee also: PSISLOOResult, waic\n\n[Vehtari2017]: Vehtari, A., Gelman, A. & Gabry, J. Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC. Stat Comput 27, 1413–1432 (2017). doi: 10.1007/s11222-016-9696-4 arXiv: 1507.04544\n\n[LOOFAQ]: Aki Vehtari. Cross-validation FAQ. https://mc-stan.org/loo/articles/online-only/faq.html\n\nExamples\n\nManually compute R_mathrmeff and calculate PSIS-LOO of a model:\n\njulia> using ArviZExampleData, MCMCDiagnosticTools\n\njulia> idata = load_example_data(\"centered_eight\");\n\njulia> log_like = PermutedDimsArray(idata.log_likelihood.obs, (:draw, :chain, :school));\n\njulia> reff = ess(log_like; kind=:basic, split_chains=1, relative=true);\n\njulia> loo(log_like; reff)\nPSISLOOResult with estimates\n elpd  elpd_mcse    p  p_mcse\n  -31        1.4  0.9    0.33\n\nand PSISResult with 500 draws, 4 chains, and 8 parameters\nPareto shape (k) diagnostic values:\n                    Count      Min. ESS\n (-Inf, 0.5]  good  5 (62.5%)  290\n  (0.5, 0.7]  okay  3 (37.5%)  399\n\n\n\n\n\nloo(data::Dataset; [var_name::Symbol,] kwargs...) -> PSISLOOResult{<:NamedTuple,<:Dataset}\nloo(data::InferenceData; [var_name::Symbol,] kwargs...) -> PSISLOOResult{<:NamedTuple,<:Dataset}\n\nCompute PSIS-LOO from log-likelihood values in data.\n\nIf more than one log-likelihood variable is present, then var_name must be provided.\n\nFor more details and a description of the kwargs, see PosteriorStats.loo.\n\nExamples\n\nCalculate PSIS-LOO of a model:\n\njulia> using ArviZExampleData, PosteriorStats\n\njulia> idata = load_example_data(\"centered_eight\");\n\njulia> loo(idata)\nPSISLOOResult with estimates\n elpd  elpd_mcse    p  p_mcse\n  -31        1.4  0.9    0.33\n\nand PSISResult with 500 draws, 4 chains, and 8 parameters\nPareto shape (k) diagnostic values:\n                    Count      Min. ESS\n (-Inf, 0.5]  good  4 (50.0%)  270\n  (0.5, 0.7]  okay  4 (50.0%)  307\n\n\n\n\n\n","category":"function"},{"location":"api/stats/#PosteriorStats.waic","page":"Stats","title":"PosteriorStats.waic","text":"waic(log_likelihood::AbstractArray) -> WAICResult{<:NamedTuple,<:NamedTuple}\n\nCompute the widely applicable information criterion (WAIC).[Watanabe2010][Vehtari2017][LOOFAQ]\n\nlog_likelihood must be an array of log-likelihood values with shape (chains, draws[, params...]).\n\nSee also: WAICResult, loo\n\n[Watanabe2010]: Watanabe, S. Asymptotic Equivalence of Bayes Cross Validation and Widely Applicable Information Criterion in Singular Learning Theory. 11(116):3571−3594, 2010. https://jmlr.csail.mit.edu/papers/v11/watanabe10a.html\n\n[Vehtari2017]: Vehtari, A., Gelman, A. & Gabry, J. Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC. Stat Comput 27, 1413–1432 (2017). doi: 10.1007/s11222-016-9696-4 arXiv: 1507.04544\n\n[LOOFAQ]: Aki Vehtari. Cross-validation FAQ. https://mc-stan.org/loo/articles/online-only/faq.html\n\nExamples\n\nCalculate WAIC of a model:\n\njulia> using ArviZExampleData\n\njulia> idata = load_example_data(\"centered_eight\");\n\njulia> log_like = PermutedDimsArray(idata.log_likelihood.obs, (:draw, :chain, :school));\n\njulia> waic(log_like)\nWAICResult with estimates\n elpd  elpd_mcse    p  p_mcse\n  -31        1.4  0.9    0.32\n\n\n\n\n\nwaic(data::Dataset; [var_name::Symbol]) -> WAICResult{<:NamedTuple,<:Dataset}\nwaic(data::InferenceData; [var_name::Symbol]) -> WAICResult{<:NamedTuple,<:Dataset}\n\nCompute WAIC from log-likelihood values in data.\n\nIf more than one log-likelihood variable is present, then var_name must be provided.\n\nSee PosteriorStats.waic for more details.\n\nExamples\n\nCalculate WAIC of a model:\n\njulia> using ArviZExampleData, PosteriorStats\n\njulia> idata = load_example_data(\"centered_eight\");\n\njulia> waic(idata)\nWAICResult with estimates\n elpd  elpd_mcse    p  p_mcse\n  -31        1.4  0.9    0.32\n\n\n\n\n\n","category":"function"},{"location":"api/stats/#Model-comparison","page":"Stats","title":"Model comparison","text":"","category":"section"},{"location":"api/stats/#PosteriorStats.ModelComparisonResult","page":"Stats","title":"PosteriorStats.ModelComparisonResult","text":"ModelComparisonResult\n\nResult of model comparison using ELPD.\n\nThis struct implements the Tables and TableTraits interfaces.\n\nEach field returns a collection of the corresponding entry for each model:\n\nname: Names of the models, if provided.\nrank: Ranks of the models (ordered by decreasing ELPD)\nelpd_diff: ELPD of a model subtracted from the largest ELPD of any model\nelpd_diff_mcse: Monte Carlo standard error of the ELPD difference\nweight: Model weights computed with weights_method\nelpd_result: AbstactELPDResults for each model, which can be used to access useful stats like ELPD estimates, pointwise estimates, and Pareto shape values for PSIS-LOO\nweights_method: Method used to compute model weights with model_weights\n\n\n\n\n\n","category":"type"},{"location":"api/stats/#PosteriorStats.compare","page":"Stats","title":"PosteriorStats.compare","text":"compare(models; kwargs...) -> ModelComparisonResult\n\nCompare models based on their expected log pointwise predictive density (ELPD).\n\nThe ELPD is estimated either by Pareto smoothed importance sampling leave-one-out cross-validation (LOO) or using the widely applicable information criterion (WAIC). We recommend loo. Read more theory here - in a paper by some of the leading authorities on model comparison dx.doi.org/10.1111/1467-9868.00353\n\nArguments\n\nmodels: a Tuple, NamedTuple, or AbstractVector whose values are either AbstractELPDResult entries or any argument to elpd_method.\n\nKeywords\n\nweights_method::AbstractModelWeightsMethod=Stacking(): the method to be used to weight the models. See model_weights for details\nelpd_method=loo: a method that computes an AbstractELPDResult from an argument in models.\nsort::Bool=true: Whether to sort models by decreasing ELPD.\n\nReturns\n\nModelComparisonResult: A container for the model comparison results. The fields contain a similar collection to models.\n\nExamples\n\nCompare the centered and non centered models of the eight school problem using the defaults: loo and Stacking weights. A custom myloo method formates the inputs as expected by loo.\n\njulia> using ArviZExampleData\n\njulia> models = (\n           centered=load_example_data(\"centered_eight\"),\n           non_centered=load_example_data(\"non_centered_eight\"),\n       );\n\njulia> function myloo(idata)\n           log_like = PermutedDimsArray(idata.log_likelihood.obs, (2, 3, 1))\n           return loo(log_like)\n       end;\n\njulia> mc = compare(models; elpd_method=myloo)\n┌ Warning: 1 parameters had Pareto shape values 0.7 < k ≤ 1. Resulting importance sampling estimates are likely to be unstable.\n└ @ PSIS ~/.julia/packages/PSIS/...\nModelComparisonResult with Stacking weights\n               rank  elpd  elpd_mcse  elpd_diff  elpd_diff_mcse  weight    p   ⋯\n non_centered     1   -31        1.5       0              0.0       1.0  0.9   ⋯\n centered         2   -31        1.4       0.03           0.061     0.0  0.9   ⋯\n                                                                1 column omitted\njulia> mc.weight |> pairs\npairs(::NamedTuple) with 2 entries:\n  :non_centered => 1.0\n  :centered     => 3.50538e-31\n\nCompare the same models from pre-computed PSIS-LOO results and computing BootstrappedPseudoBMA weights:\n\njulia> elpd_results = mc.elpd_result;\n\njulia> compare(elpd_results; weights_method=BootstrappedPseudoBMA())\nModelComparisonResult with BootstrappedPseudoBMA weights\n               rank  elpd  elpd_mcse  elpd_diff  elpd_diff_mcse  weight    p   ⋯\n non_centered     1   -31        1.5       0              0.0      0.51  0.9   ⋯\n centered         2   -31        1.4       0.03           0.061    0.49  0.9   ⋯\n                                                                1 column omitted\n\n\n\n\n\n","category":"function"},{"location":"api/stats/#PosteriorStats.model_weights","page":"Stats","title":"PosteriorStats.model_weights","text":"model_weights(elpd_results; method=Stacking())\nmodel_weights(method::AbstractModelWeightsMethod, elpd_results)\n\nCompute weights for each model in elpd_results using method.\n\nelpd_results is a Tuple, NamedTuple, or AbstractVector with AbstractELPDResult entries. The weights are returned in the same type of collection.\n\nStacking is the recommended approach, as it performs well even when the true data generating process is not included among the candidate models. See [YaoVehtari2018] for details.\n\nSee also: AbstractModelWeightsMethod, compare\n\n[YaoVehtari2018]: Yuling Yao, Aki Vehtari, Daniel Simpson, and Andrew Gelman.                Using Stacking to Average Bayesian Predictive Distributions.                2018. Bayesian Analysis. 13, 3, 917–1007.                doi: 10.1214/17-BA1091                arXiv: 1704.02030\n\nExamples\n\nCompute Stacking weights for two models:\n\njulia> using ArviZExampleData\n\njulia> models = (\n           centered=load_example_data(\"centered_eight\"),\n           non_centered=load_example_data(\"non_centered_eight\"),\n       );\n\njulia> elpd_results = map(models) do idata\n           log_like = PermutedDimsArray(idata.log_likelihood.obs, (2, 3, 1))\n           return loo(log_like)\n       end;\n┌ Warning: 1 parameters had Pareto shape values 0.7 < k ≤ 1. Resulting importance sampling estimates are likely to be unstable.\n└ @ PSIS ~/.julia/packages/PSIS/...\n\njulia> model_weights(elpd_results; method=Stacking()) |> pairs\npairs(::NamedTuple) with 2 entries:\n  :centered     => 3.50546e-31\n  :non_centered => 1.0\n\nNow we compute BootstrappedPseudoBMA weights for the same models:\n\njulia> model_weights(elpd_results; method=BootstrappedPseudoBMA()) |> pairs\npairs(::NamedTuple) with 2 entries:\n  :centered     => 0.492513\n  :non_centered => 0.507487\n\n\n\n\n\n","category":"function"},{"location":"api/stats/","page":"Stats","title":"Stats","text":"The following model weighting methods are available","category":"page"},{"location":"api/stats/#PosteriorStats.AbstractModelWeightsMethod","page":"Stats","title":"PosteriorStats.AbstractModelWeightsMethod","text":"abstract type AbstractModelWeightsMethod\n\nAn abstract type representing methods for computing model weights.\n\nSubtypes implement model_weights(method, elpd_results).\n\n\n\n\n\n","category":"type"},{"location":"api/stats/#PosteriorStats.BootstrappedPseudoBMA","page":"Stats","title":"PosteriorStats.BootstrappedPseudoBMA","text":"struct BootstrappedPseudoBMA{R<:Random.AbstractRNG, T<:Real} <: AbstractModelWeightsMethod\n\nModel weighting method using pseudo Bayesian Model Averaging using Akaike-type weighting with the Bayesian bootstrap (pseudo-BMA+)[YaoVehtari2018].\n\nThe Bayesian bootstrap stabilizes the model weights.\n\nBootstrappedPseudoBMA(; rng=Random.default_rng(), samples=1_000, alpha=1)\nBootstrappedPseudoBMA(rng, samples, alpha)\n\nConstruct the method.\n\nrng::Random.AbstractRNG: The random number generator to use for the Bayesian bootstrap\nsamples::Int64: The number of samples to draw for bootstrapping\nalpha::Real: The shape parameter in the Dirichlet distribution used for the Bayesian bootstrap. The default (1) corresponds to a uniform distribution on the simplex.\n\nSee also: Stacking\n\n[YaoVehtari2018]: Yuling Yao, Aki Vehtari, Daniel Simpson, and Andrew Gelman.                Using Stacking to Average Bayesian Predictive Distributions.                2018. Bayesian Analysis. 13, 3, 917–1007.                doi: 10.1214/17-BA1091                arXiv: 1704.02030\n\n\n\n\n\n","category":"type"},{"location":"api/stats/#PosteriorStats.PseudoBMA","page":"Stats","title":"PosteriorStats.PseudoBMA","text":"struct PseudoBMA <: AbstractModelWeightsMethod\n\nModel weighting method using pseudo Bayesian Model Averaging (pseudo-BMA) and Akaike-type weighting.\n\nPseudoBMA(; regularize=false)\nPseudoBMA(regularize)\n\nConstruct the method with optional regularization of the weights using the standard error of the ELPD estimate.\n\nnote: Note\nThis approach is not recommended, as it produces unstable weight estimates. It is recommended to instead use BootstrappedPseudoBMA to stabilize the weights or Stacking. For details, see [YaoVehtari2018].\n\n[YaoVehtari2018]: Yuling Yao, Aki Vehtari, Daniel Simpson, and Andrew Gelman.                Using Stacking to Average Bayesian Predictive Distributions.                2018. Bayesian Analysis. 13, 3, 917–1007.                doi: 10.1214/17-BA1091                arXiv: 1704.02030\n\nSee also: Stacking\n\n\n\n\n\n","category":"type"},{"location":"api/stats/#PosteriorStats.Stacking","page":"Stats","title":"PosteriorStats.Stacking","text":"struct Stacking{O<:Optim.AbstractOptimizer} <: AbstractModelWeightsMethod\n\nModel weighting using stacking of predictive distributions[YaoVehtari2018].\n\nStacking(; optimizer=Optim.LBFGS(), options=Optim.Options()\nStacking(optimizer[, options])\n\nConstruct the method, optionally customizing the optimization.\n\noptimizer::Optim.AbstractOptimizer: The optimizer to use for the optimization of the weights. The optimizer must support projected gradient optimization via a manifold field.\noptions::Optim.Options: The Optim options to use for the optimization of the weights.\n\nSee also: BootstrappedPseudoBMA\n\n[YaoVehtari2018]: Yuling Yao, Aki Vehtari, Daniel Simpson, and Andrew Gelman.                Using Stacking to Average Bayesian Predictive Distributions.                2018. Bayesian Analysis. 13, 3, 917–1007.                doi: 10.1214/17-BA1091                arXiv: 1704.02030\n\n\n\n\n\n","category":"type"},{"location":"api/stats/#Predictive-checks","page":"Stats","title":"Predictive checks","text":"","category":"section"},{"location":"api/stats/#PosteriorStats.loo_pit","page":"Stats","title":"PosteriorStats.loo_pit","text":"loo_pit(y, y_pred, log_weights; kwargs...) -> Union{Real,AbstractArray}\n\nCompute leave-one-out probability integral transform (LOO-PIT) checks.\n\nArguments\n\ny: array of observations with shape (params...,)\ny_pred: array of posterior predictive samples with shape (draws, chains, params...).\nlog_weights: array of normalized log LOO importance weights with shape (draws, chains, params...).\n\nKeywords\n\nis_discrete: If not provided, then it is set to true iff elements of y and y_pred are all integer-valued. If true, then data are smoothed using smooth_data to make them non-discrete before estimating LOO-PIT values.\nkwargs: Remaining keywords are forwarded to smooth_data if data is discrete.\n\nReturns\n\npitvals: LOO-PIT values with same size as y. If y is a scalar, then pitvals is a scalar.\n\nLOO-PIT is a marginal posterior predictive check. If y_-i is the array y of observations with the ith observation left out, and y_i^* is a posterior prediction of the ith observation, then the LOO-PIT value for the ith observation is defined as\n\nP(y_i^* le y_i mid y_-i) = int_-infty^y_i p(y_i^* mid y_-i) mathrmd y_i^*\n\nThe LOO posterior predictions and the corresponding observations should have similar distributions, so if conditional predictive distributions are well-calibrated, then all LOO-PIT values should be approximately uniformly distributed on 0 1.[Gabry2019]\n\n[Gabry2019]: Gabry, J., Simpson, D., Vehtari, A., Betancourt, M. & Gelman, A. Visualization in Bayesian Workflow. J. R. Stat. Soc. Ser. A Stat. Soc. 182, 389–402 (2019). doi: 10.1111/rssa.12378 arXiv: 1709.01449\n\nExamples\n\nCalculate LOO-PIT values using as test quantity the observed values themselves.\n\njulia> using ArviZExampleData\n\njulia> idata = load_example_data(\"centered_eight\");\n\njulia> y = idata.observed_data.obs;\n\njulia> y_pred = PermutedDimsArray(idata.posterior_predictive.obs, (:draw, :chain, :school));\n\njulia> log_like = PermutedDimsArray(idata.log_likelihood.obs, (:draw, :chain, :school));\n\njulia> log_weights = loo(log_like).psis_result.log_weights;\n\njulia> loo_pit(y, y_pred, log_weights)\n┌ 8-element DimArray{Float64, 1} ┐\n├────────────────────────────────┴─────────────────────────────── dims ┐\n  ↓ school Categorical{String} [\"Choate\", …, \"Mt. Hermon\"] Unordered\n└──────────────────────────────────────────────────────────────────────┘\n \"Choate\"            0.942759\n \"Deerfield\"         0.641057\n \"Phillips Andover\"  0.32729\n \"Phillips Exeter\"   0.581451\n \"Hotchkiss\"         0.288523\n \"Lawrenceville\"     0.393741\n \"St. Paul's\"        0.886175\n \"Mt. Hermon\"        0.638821\n\nCalculate LOO-PIT values using as test quantity the square of the difference between each observation and mu.\n\njulia> using Statistics\n\njulia> mu = idata.posterior.mu;\n\njulia> T = y .- median(mu);\n\njulia> T_pred = y_pred .- mu;\n\njulia> loo_pit(T .^ 2, T_pred .^ 2, log_weights)\n┌ 8-element DimArray{Float64, 1} ┐\n├────────────────────────────────┴─────────────────────────────── dims ┐\n  ↓ school Categorical{String} [\"Choate\", …, \"Mt. Hermon\"] Unordered\n└──────────────────────────────────────────────────────────────────────┘\n \"Choate\"            0.868148\n \"Deerfield\"         0.27421\n \"Phillips Andover\"  0.321719\n \"Phillips Exeter\"   0.193169\n \"Hotchkiss\"         0.370422\n \"Lawrenceville\"     0.195601\n \"St. Paul's\"        0.817408\n \"Mt. Hermon\"        0.326795\n\n\n\n\n\nloo_pit(idata::InferenceData, log_weights; kwargs...) -> DimArray\n\nCompute LOO-PIT values using existing normalized log LOO importance weights.\n\nKeywords\n\ny_name: Name of observed data variable in idata.observed_data. If not provided, then the only observed data variable is used.\ny_pred_name: Name of posterior predictive variable in idata.posterior_predictive. If not provided, then y_name is used.\nkwargs: Remaining keywords are forwarded to the base method PosteriorStats.loo_pit.\n\nSee PosteriorStats.loo_pit for more details.\n\nExamples\n\nCalculate LOO-PIT values using already computed log weights.\n\njulia> using ArviZExampleData, PosteriorStats\n\njulia> idata = load_example_data(\"centered_eight\");\n\njulia> loo_result = loo(idata; var_name=:obs);\n\njulia> loo_pit(idata, loo_result.psis_result.log_weights; y_name=:obs)\n┌ 8-element DimArray{Float64, 1} loo_pit_obs ┐\n├────────────────────────────────────────────┴─────────────────── dims ┐\n  ↓ school Categorical{String} [\"Choate\", …, \"Mt. Hermon\"] Unordered\n└──────────────────────────────────────────────────────────────────────┘\n \"Choate\"            0.942759\n \"Deerfield\"         0.641057\n \"Phillips Andover\"  0.32729\n \"Phillips Exeter\"   0.581451\n \"Hotchkiss\"         0.288523\n \"Lawrenceville\"     0.393741\n \"St. Paul's\"        0.886175\n \"Mt. Hermon\"        0.638821\n\n\n\n\n\nloo_pit(idata::InferenceData; kwargs...) -> DimArray\n\nCompute LOO-PIT from groups in idata using PSIS-LOO.\n\nKeywords\n\ny_name: Name of observed data variable in idata.observed_data. If not provided, then the only observed data variable is used.\ny_pred_name: Name of posterior predictive variable in idata.posterior_predictive. If not provided, then y_name is used.\nlog_likelihood_name: Name of log-likelihood variable in idata.log_likelihood. If not provided, then y_name is used if idata has a log_likelihood group, otherwise the only variable is used.\nreff::Union{Real,AbstractArray{<:Real}}: The relative effective sample size(s) of the likelihood values. If an array, it must have the same data dimensions as the corresponding log-likelihood variable. If not provided, then this is estimated using ess.\nkwargs: Remaining keywords are forwarded to PosteriorStats.loo_pit.\n\nSee PosteriorStats.loo_pit for more details.\n\nExamples\n\nCalculate LOO-PIT values using as test quantity the observed values themselves.\n\njulia> using ArviZExampleData, PosteriorStats\n\njulia> idata = load_example_data(\"centered_eight\");\n\njulia> loo_pit(idata; y_name=:obs)\n┌ 8-element DimArray{Float64, 1} loo_pit_obs ┐\n├────────────────────────────────────────────┴─────────────────── dims ┐\n  ↓ school Categorical{String} [\"Choate\", …, \"Mt. Hermon\"] Unordered\n└──────────────────────────────────────────────────────────────────────┘\n \"Choate\"            0.942759\n \"Deerfield\"         0.641057\n \"Phillips Andover\"  0.32729\n \"Phillips Exeter\"   0.581451\n \"Hotchkiss\"         0.288523\n \"Lawrenceville\"     0.393741\n \"St. Paul's\"        0.886175\n \"Mt. Hermon\"        0.638821\n\n\n\n\n\n","category":"function"},{"location":"api/stats/#Utilities","page":"Stats","title":"Utilities","text":"","category":"section"},{"location":"api/stats/#PosteriorStats.smooth_data","page":"Stats","title":"PosteriorStats.smooth_data","text":"smooth_data(y; dims=:, interp_method=CubicSpline, offset_frac=0.01)\n\nSmooth y along dims using interp_method.\n\ninterp_method is a 2-argument callabale that takes the arguments y and x and returns a DataInterpolations.jl interpolation method, defaulting to a cubic spline interpolator.\n\noffset_frac is the fraction of the length of y to use as an offset when interpolating.\n\n\n\n\n\n","category":"function"},{"location":"api/dataset/#dataset-api","page":"Dataset","title":"Dataset","text":"","category":"section"},{"location":"api/dataset/","page":"Dataset","title":"Dataset","text":"Pages = [\"dataset.md\"]","category":"page"},{"location":"api/dataset/#Type-definition","page":"Dataset","title":"Type definition","text":"","category":"section"},{"location":"api/dataset/#InferenceObjects.Dataset","page":"Dataset","title":"InferenceObjects.Dataset","text":"Dataset{K,T,N,L} <: DimensionalData.AbstractDimStack{K,T,N,L}\n\nContainer of dimensional arrays sharing some dimensions.\n\nThis type is an DimensionalData.AbstractDimStack that implements the same interface as DimensionalData.DimStack and has identical usage.\n\nConstructors\n\nDataset(data::DimensionalData.AbstractDimArray...)\nDataset(data::Tuple{Vararg{<:DimensionalData.AbstractDimArray}})\nDataset(data::NamedTuple{Keys,Vararg{<:DimensionalData.AbstractDimArray}})\nDataset(\n    data::NamedTuple,\n    dims::Tuple{Vararg{DimensionalData.Dimension}};\n    metadata=DimensionalData.NoMetadata(),\n)\n\nIn most cases, use convert_to_dataset to create a Dataset instead of directly using a constructor.\n\n\n\n\n\n","category":"type"},{"location":"api/dataset/#General-conversion","page":"Dataset","title":"General conversion","text":"","category":"section"},{"location":"api/dataset/#InferenceObjects.convert_to_dataset","page":"Dataset","title":"InferenceObjects.convert_to_dataset","text":"convert_to_dataset(obj; group = :posterior, kwargs...) -> Dataset\n\nConvert a supported object to a Dataset.\n\nIn most cases, this function calls convert_to_inference_data and returns the corresponding group.\n\n\n\n\n\n","category":"function"},{"location":"api/dataset/#InferenceObjects.namedtuple_to_dataset","page":"Dataset","title":"InferenceObjects.namedtuple_to_dataset","text":"namedtuple_to_dataset(data; kwargs...) -> Dataset\n\nConvert NamedTuple mapping variable names to arrays to a Dataset.\n\nAny non-array values will be converted to a 0-dimensional array.\n\nKeywords\n\nattrs::AbstractDict{<:AbstractString}: a collection of metadata to attach to the dataset, in addition to defaults. Values should be JSON serializable.\nlibrary::Union{String,Module}: library used for performing inference. Will be attached to the attrs metadata.\ndims: a collection mapping variable names to collections of objects containing dimension names. Acceptable such objects are:\nSymbol: dimension name\nType{<:DimensionsionalData.Dimension}: dimension type\nDimensionsionalData.Dimension: dimension, potentially with indices\nNothing: no dimension name provided, dimension name is automatically generated\ncoords: a collection indexable by dimension name specifying the indices of the given dimension. If indices for a dimension in dims are provided, they are used even if the dimension contains its own indices. If a dimension is missing, its indices are automatically generated.\n\n\n\n\n\n","category":"function"},{"location":"api/dataset/#DimensionalData","page":"Dataset","title":"DimensionalData","text":"","category":"section"},{"location":"api/dataset/","page":"Dataset","title":"Dataset","text":"As a DimensionalData.AbstractDimStack, Dataset also implements the AbstractDimStack API and can be used like a DimStack. See DimensionalData's documentation for example usage.","category":"page"},{"location":"api/dataset/#Tables-inteface","page":"Dataset","title":"Tables inteface","text":"","category":"section"},{"location":"api/dataset/","page":"Dataset","title":"Dataset","text":"Dataset implements the Tables interface. This allows Datasets to be used as sources for any function that can accept a table. For example, it's straightforward to:","category":"page"},{"location":"api/dataset/","page":"Dataset","title":"Dataset","text":"write to CSV with CSV.jl\nflatten to a DataFrame with DataFrames.jl\nplot with StatsPlots.jl\nplot with AlgebraOfGraphics.jl","category":"page"},{"location":"#arvizjl","page":"Home","title":"ArviZ.jl: Exploratory analysis of Bayesian models in Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ArviZ.jl is a Julia meta-package for exploratory analysis of Bayesian models. It is part of the ArviZ project, which also includes a related Python package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ArviZ consists of and re-exports the following subpackages, along with extensions integrating them with InferenceObjects:","category":"page"},{"location":"","page":"Home","title":"Home","text":"InferenceObjects.jl: a base package implementing the InferenceData type with utilities for building, saving, and working with it\nMCMCDiagnosticTools.jl: diagnostics for Markov Chain Monte Carlo methods\nPSIS.jl: Pareto-smoothed importance sampling\nPosteriorStats.jl: common statistical analyses for the Bayesian workflow","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additional functionality can be loaded with the following packages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ArviZExampleData.jl: example InferenceData objects, useful for demonstration and testing\nArviZPythonPlots.jl: Python ArviZ's library of plotting functions for Julia types","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the navigation bar for more useful packages.","category":"page"},{"location":"#installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"From the Julia REPL, type ] to enter the Pkg REPL mode and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add ArviZ","category":"page"},{"location":"#usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the ArviZ Quickstart for example usage and the API Overview for description of functions.","category":"page"},{"location":"#extendingarviz","page":"Home","title":"Extending ArviZ.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use a custom data type with ArviZ.jl, simply overload InferenceObjects.convert_to_inference_data to convert your input(s) to an InferenceObjects.InferenceData.","category":"page"},{"location":"working_with_inference_data/#working-with-inference-data","page":"Working with InferenceData","title":"Working with InferenceData","text":"","category":"section"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"using ArviZ, ArviZExampleData, DimensionalData, Statistics","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"Here we present a collection of common manipulations you can use while working with InferenceData.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"Let's load one of ArviZ's example datasets. posterior, posterior_predictive, etc are the groups stored in idata, and they are stored as Datasets. In this HTML view, you can click a group name to expand a summary of the group.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"idata = load_example_data(\"centered_eight\")","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"info: Info\nDatasets are DimensionalData.AbstractDimStacks and can be used identically.   The variables a Dataset contains are called \"layers\", and dimensions of the same name that appear in more than one layer within a Dataset must have the same indices.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"InferenceData behaves like a NamedTuple and can be used similarly. Note that unlike a NamedTuple, the groups always appear in a specific order.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"length(idata) # number of groups","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"keys(idata) # group names","category":"page"},{"location":"working_with_inference_data/#Get-the-dataset-corresponding-to-a-single-group","page":"Working with InferenceData","title":"Get the dataset corresponding to a single group","text":"","category":"section"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"Group datasets can be accessed both as properties or as indexed items.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"post = idata.posterior","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"post is the dataset itself, so this is a non-allocating operation.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"idata[:posterior] === post","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"InferenceData supports a more advanced indexing syntax, which we'll see later.","category":"page"},{"location":"working_with_inference_data/#Getting-a-new-InferenceData-with-a-subset-of-groups","page":"Working with InferenceData","title":"Getting a new InferenceData with a subset of groups","text":"","category":"section"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"We can index by a collection of group names to get a new InferenceData with just those groups. This is also non-allocating.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"idata_sub = idata[(:posterior, :posterior_predictive)]","category":"page"},{"location":"working_with_inference_data/#Adding-groups-to-an-InferenceData","page":"Working with InferenceData","title":"Adding groups to an InferenceData","text":"","category":"section"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"InferenceData is immutable, so to add or replace groups we use merge to create a new object.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"merge(idata_sub, idata[(:observed_data, :prior)])","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"We can also use Base.setindex to out-of-place add or replace a single group.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"Base.setindex(idata_sub, idata.prior, :prior)","category":"page"},{"location":"working_with_inference_data/#Add-a-new-variable","page":"Working with InferenceData","title":"Add a new variable","text":"","category":"section"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"Dataset is also immutable. So while the values within the underlying data arrays can be mutated, layers cannot be added or removed from Datasets, and groups cannot be added/removed from InferenceData.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"Instead, we do this out-of-place also using merge.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"merge(post, (log_tau=log.(post[:tau]),))","category":"page"},{"location":"working_with_inference_data/#Obtain-an-array-for-a-given-parameter","page":"Working with InferenceData","title":"Obtain an array for a given parameter","text":"","category":"section"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"Let’s say we want to get the values for mu as an array. Parameters can be accessed with either property or index syntax.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"post.tau","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"post[:tau] === post.tau","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"To remove the dimensions, just use parent to retrieve the underlying array.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"parent(post.tau)","category":"page"},{"location":"working_with_inference_data/#Get-the-dimension-lengths","page":"Working with InferenceData","title":"Get the dimension lengths","text":"","category":"section"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"Let’s check how many groups are in our hierarchical model.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"size(idata.observed_data, :school)","category":"page"},{"location":"working_with_inference_data/#Get-coordinate/index-values","page":"Working with InferenceData","title":"Get coordinate/index values","text":"","category":"section"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"What are the names of the groups in our hierarchical model? You can access them from the coordinate name school in this case.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"DimensionalData.index(idata.observed_data, :school)","category":"page"},{"location":"working_with_inference_data/#Get-a-subset-of-chains","page":"Working with InferenceData","title":"Get a subset of chains","text":"","category":"section"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"Let’s keep only chain 0 here. For the subset to take effect on all relevant InferenceData groups – posterior, sample_stats, log_likelihood, and posterior_predictive – we will index InferenceData instead of Dataset.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"Here we use DimensionalData's At selector. Its other selectors are also supported.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"idata[chain=At(0)]","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"Note that in this case, prior only has a chain of 0. If it also had the other chains, we could have passed chain=At([0, 2]) to subset by chains 0 and 2.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"warning: Warning\nIf we used idata[chain=[0, 2]] without the At selector, this is equivalent to idata[chain=DimensionalData.index(idata.posterior, :chain)[0, 2]], that is, [0, 2] indexes an array of dimension indices, which here would error.   But if we had requested idata[chain=[1, 2]] we would not hit an error, but we would index the wrong chains.   So it's important to always use a selector to index by values of dimension indices.","category":"page"},{"location":"working_with_inference_data/#Remove-the-first-n-draws-(burn-in)","page":"Working with InferenceData","title":"Remove the first n draws (burn-in)","text":"","category":"section"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"Let’s say we want to remove the first 100 draws from all the chains and all InferenceData groups with draws. To do this we use the .. syntax from IntervalSets.jl, which is exported by DimensionalData.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"idata[draw=100 .. Inf]","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"If you check the object you will see that the groups posterior, posterior_predictive, prior, and sample_stats have 400 draws compared to idata, which has 500. The group observed_data has not been affected because it does not have the draw dimension.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"Alternatively, you can change a subset of groups by combining indexing styles with merge. Here we use this to build a new InferenceData where we have discarded the first 100 draws only from posterior.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"merge(idata, idata[(:posterior,), draw=100 .. Inf])","category":"page"},{"location":"working_with_inference_data/#Compute-posterior-mean-values-along-draw-and-chain-dimensions","page":"Working with InferenceData","title":"Compute posterior mean values along draw and chain dimensions","text":"","category":"section"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"To compute the mean value of the posterior samples, do the following:","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"mean(post)","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"This computes the mean along all dimensions, discarding all dimensions and returning the result as a NamedTuple. This may be what you wanted for mu and tau, which have only two dimensions (chain and draw), but maybe not what you expected for theta, which has one more dimension school.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"You can specify along which dimension you want to compute the mean (or other functions), which instead returns a Dataset.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"mean(post; dims=(:chain, :draw))","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"The singleton dimensions of chain and draw now contain meaningless indices, so you may want to discard them, which you can do with dropdims.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"dropdims(mean(post; dims=(:chain, :draw)); dims=(:chain, :draw))","category":"page"},{"location":"working_with_inference_data/#Renaming-a-dimension","page":"Working with InferenceData","title":"Renaming a dimension","text":"","category":"section"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"We can rename a dimension in a Dataset using DimensionalData's set method:","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"theta_bis = set(post.theta; school=:school_bis)","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"We can use this, for example, to broadcast functions across multiple arrays, automatically matching up shared dimensions, using DimensionalData.broadcast_dims.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"theta_school_diff = broadcast_dims(-, post.theta, theta_bis)","category":"page"},{"location":"working_with_inference_data/#Compute-and-store-posterior-pushforward-quantities","page":"Working with InferenceData","title":"Compute and store posterior pushforward quantities","text":"","category":"section"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"We use “posterior pushfoward quantities” to refer to quantities that are not variables in the posterior but deterministic computations using posterior variables.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"You can compute these pushforward operations and store them as a new variable in a copy of the posterior group.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"Here we'll create a new InferenceData with theta_school_diff in the posterior:","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"idata_new = Base.setindex(idata, merge(post, (; theta_school_diff)), :posterior)","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"Once you have these pushforward quantities in an InferenceData, you’ll then be able to plot them with ArviZ functions, calculate stats and diagnostics on them, or save and share the InferenceData object with the pushforward quantities included.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"Here we compute the mcse of theta_school_diff:","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"mcse(idata_new.posterior).theta_school_diff","category":"page"},{"location":"working_with_inference_data/#Advanced-subsetting","page":"Working with InferenceData","title":"Advanced subsetting","text":"","category":"section"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"To select the value corresponding to the difference between the Choate and Deerfield schools do:","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"school_idx = [\"Choate\", \"Hotchkiss\", \"Mt. Hermon\"]\nschool_bis_idx = [\"Deerfield\", \"Choate\", \"Lawrenceville\"]\ntheta_school_diff[school=At(school_idx), school_bis=At(school_bis_idx)]","category":"page"},{"location":"working_with_inference_data/#Add-new-chains-using-cat","page":"Working with InferenceData","title":"Add new chains using cat","text":"","category":"section"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"Suppose after checking the mcse and realizing you need more samples, you rerun the model with two chains and obtain an idata_rerun object.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"idata_rerun = InferenceData(; posterior=set(post[chain=At([0, 1])]; chain=[4, 5]))","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"You can combine the two using cat.","category":"page"},{"location":"working_with_inference_data/","page":"Working with InferenceData","title":"Working with InferenceData","text":"cat(idata[[:posterior]], idata_rerun; dims=:chain)","category":"page"}]
}
