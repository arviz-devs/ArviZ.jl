{
  "hash": "b9eb41d6b7002b7cad3bfd97ca1e05ed",
  "result": {
    "markdown": "---\ntitle: \"Creating custom plots\"\n---\n\nWhile ArviZ includes many plotting functions for visualizing the data stored in [`InferenceData`](@ref) objects, you will often need to construct custom plots, or you may want to tweak some of our plots in your favorite plotting package.\n\nIn this tutorial, we will show you a few useful techniques you can use to construct these plots using Julia's plotting packages.\nFor demonstration purposes, we'll use Makie.jl and AlgebraOfGraphics.jl, which can consume [`Dataset`](@ref) objects since they implement the Tables interface.\nHowever, we could just as easily have used StatsPlots.jl.\n\n\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nusing ArviZ, DimensionalData, DataFrames, Statistics, AlgebraOfGraphics, CairoMakie\nusing AlgebraOfGraphics: density\nset_aog_theme!()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/home/runner/.julia/conda/3/x86_64/lib/python3.10/site-packages/scipy/__init__.py:146: UserWarning: A NumPy version >=1.17.3 and <1.25.0 is required for this version of SciPy (detected version 1.25.0\n  warnings.warn(f\"A NumPy version >={np_minversion} and <{np_maxversion}\"\n```\n:::\n:::\n\n\nWe'll start by loading some draws from an implementation of the non-centered parameterization of the 8 schools model.\nIn this parameterization, the model has some sampling issues.\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nidata = load_example_data(\"centered_eight\")\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>InferenceData<details>\n<summary>posterior</summary>\n<pre><code>Dataset with dimensions: \n  Dim{:draw} Sampled{Int64} Int64[0, 1, …, 498, 499] ForwardOrdered Irregular Points,\n  Dim{:chain} Sampled{Int64} Int64[0, 1, 2, 3] ForwardOrdered Irregular Points,\n  Dim{:school} Categorical{String} String[Choate, Deerfield, …, St. Paul's, Mt. Hermon] Unordered\nand 3 layers:\n  :mu    Float64 dims: Dim{:draw}, Dim{:chain} (500×4)\n  :theta Float64 dims: Dim{:school}, Dim{:draw}, Dim{:chain} (8×500×4)\n  :tau   Float64 dims: Dim{:draw}, Dim{:chain} (500×4)\n\nwith metadata Dict{String, Any} with 6 entries:\n  \"created_at\" => \"2022-10-13T14:37:37.315398\"\n  \"inference_library_version\" => \"4.2.2\"\n  \"sampling_time\" => 7.48011\n  \"tuning_steps\" => 1000\n  \"arviz_version\" => \"0.13.0.dev0\"\n  \"inference_library\" => \"pymc\"</code></pre>\n</details>\n<details>\n<summary>posterior_predictive</summary>\n<pre><code>Dataset with dimensions: \n  Dim{:school} Categorical{String} String[Choate, Deerfield, …, St. Paul's, Mt. Hermon] Unordered,\n  Dim{:draw} Sampled{Int64} Int64[0, 1, …, 498, 499] ForwardOrdered Irregular Points,\n  Dim{:chain} Sampled{Int64} Int64[0, 1, 2, 3] ForwardOrdered Irregular Points\nand 1 layer:\n  :obs Float64 dims: Dim{:school}, Dim{:draw}, Dim{:chain} (8×500×4)\n\nwith metadata Dict{String, Any} with 4 entries:\n  \"created_at\" => \"2022-10-13T14:37:41.460544\"\n  \"inference_library_version\" => \"4.2.2\"\n  \"arviz_version\" => \"0.13.0.dev0\"\n  \"inference_library\" => \"pymc\"</code></pre>\n</details>\n<details>\n<summary>log_likelihood</summary>\n<pre><code>Dataset with dimensions: \n  Dim{:school} Categorical{String} String[Choate, Deerfield, …, St. Paul's, Mt. Hermon] Unordered,\n  Dim{:draw} Sampled{Int64} Int64[0, 1, …, 498, 499] ForwardOrdered Irregular Points,\n  Dim{:chain} Sampled{Int64} Int64[0, 1, 2, 3] ForwardOrdered Irregular Points\nand 1 layer:\n  :obs Float64 dims: Dim{:school}, Dim{:draw}, Dim{:chain} (8×500×4)\n\nwith metadata Dict{String, Any} with 4 entries:\n  \"created_at\" => \"2022-10-13T14:37:37.487399\"\n  \"inference_library_version\" => \"4.2.2\"\n  \"arviz_version\" => \"0.13.0.dev0\"\n  \"inference_library\" => \"pymc\"</code></pre>\n</details>\n<details>\n<summary>sample_stats</summary>\n<pre><code>Dataset with dimensions: \n  Dim{:draw} Sampled{Int64} Int64[0, 1, …, 498, 499] ForwardOrdered Irregular Points,\n  Dim{:chain} Sampled{Int64} Int64[0, 1, 2, 3] ForwardOrdered Irregular Points\nand 16 layers:\n  :max_energy_error    Float64 dims: Dim{:draw}, Dim{:chain} (500×4)\n  :energy_error        Float64 dims: Dim{:draw}, Dim{:chain} (500×4)\n  :lp                  Float64 dims: Dim{:draw}, Dim{:chain} (500×4)\n  :index_in_trajectory Int64 dims: Dim{:draw}, Dim{:chain} (500×4)\n  :acceptance_rate     Float64 dims: Dim{:draw}, Dim{:chain} (500×4)\n  :diverging           Bool dims: Dim{:draw}, Dim{:chain} (500×4)\n  :process_time_diff   Float64 dims: Dim{:draw}, Dim{:chain} (500×4)\n  :n_steps             Float64 dims: Dim{:draw}, Dim{:chain} (500×4)\n  :perf_counter_start  Float64 dims: Dim{:draw}, Dim{:chain} (500×4)\n  :largest_eigval      Union{Missing, Float64} dims: Dim{:draw}, Dim{:chain} (500×4)\n  :smallest_eigval     Union{Missing, Float64} dims: Dim{:draw}, Dim{:chain} (500×4)\n  :step_size_bar       Float64 dims: Dim{:draw}, Dim{:chain} (500×4)\n  :step_size           Float64 dims: Dim{:draw}, Dim{:chain} (500×4)\n  :energy              Float64 dims: Dim{:draw}, Dim{:chain} (500×4)\n  :tree_depth          Int64 dims: Dim{:draw}, Dim{:chain} (500×4)\n  :perf_counter_diff   Float64 dims: Dim{:draw}, Dim{:chain} (500×4)\n\nwith metadata Dict{String, Any} with 6 entries:\n  \"created_at\" => \"2022-10-13T14:37:37.324929\"\n  \"inference_library_version\" => \"4.2.2\"\n  \"sampling_time\" => 7.48011\n  \"tuning_steps\" => 1000\n  \"arviz_version\" => \"0.13.0.dev0\"\n  \"inference_library\" => \"pymc\"</code></pre>\n</details>\n<details>\n<summary>prior</summary>\n<pre><code>Dataset with dimensions: \n  Dim{:draw} Sampled{Int64} Int64[0, 1, …, 498, 499] ForwardOrdered Irregular Points,\n  Dim{:chain} Sampled{Int64} Int64[0] ForwardOrdered Irregular Points,\n  Dim{:school} Categorical{String} String[Choate, Deerfield, …, St. Paul's, Mt. Hermon] Unordered\nand 3 layers:\n  :tau   Float64 dims: Dim{:draw}, Dim{:chain} (500×1)\n  :theta Float64 dims: Dim{:school}, Dim{:draw}, Dim{:chain} (8×500×1)\n  :mu    Float64 dims: Dim{:draw}, Dim{:chain} (500×1)\n\nwith metadata Dict{String, Any} with 4 entries:\n  \"created_at\" => \"2022-10-13T14:37:26.602116\"\n  \"inference_library_version\" => \"4.2.2\"\n  \"arviz_version\" => \"0.13.0.dev0\"\n  \"inference_library\" => \"pymc\"</code></pre>\n</details>\n<details>\n<summary>prior_predictive</summary>\n<pre><code>Dataset with dimensions: \n  Dim{:school} Categorical{String} String[Choate, Deerfield, …, St. Paul's, Mt. Hermon] Unordered,\n  Dim{:draw} Sampled{Int64} Int64[0, 1, …, 498, 499] ForwardOrdered Irregular Points,\n  Dim{:chain} Sampled{Int64} Int64[0] ForwardOrdered Irregular Points\nand 1 layer:\n  :obs Float64 dims: Dim{:school}, Dim{:draw}, Dim{:chain} (8×500×1)\n\nwith metadata Dict{String, Any} with 4 entries:\n  \"created_at\" => \"2022-10-13T14:37:26.604969\"\n  \"inference_library_version\" => \"4.2.2\"\n  \"arviz_version\" => \"0.13.0.dev0\"\n  \"inference_library\" => \"pymc\"</code></pre>\n</details>\n<details>\n<summary>observed_data</summary>\n<pre><code>Dataset with dimensions: \n  Dim{:school} Categorical{String} String[Choate, Deerfield, …, St. Paul's, Mt. Hermon] Unordered\nand 1 layer:\n  :obs Float64 dims: Dim{:school} (8)\n\nwith metadata Dict{String, Any} with 4 entries:\n  \"created_at\" => \"2022-10-13T14:37:26.606375\"\n  \"inference_library_version\" => \"4.2.2\"\n  \"arviz_version\" => \"0.13.0.dev0\"\n  \"inference_library\" => \"pymc\"</code></pre>\n</details>\n<details>\n<summary>constant_data</summary>\n<pre><code>Dataset with dimensions: \n  Dim{:school} Categorical{String} String[Choate, Deerfield, …, St. Paul's, Mt. Hermon] Unordered\nand 1 layer:\n  :scores Float64 dims: Dim{:school} (8)\n\nwith metadata Dict{String, Any} with 4 entries:\n  \"created_at\" => \"2022-10-13T14:37:26.607471\"\n  \"inference_library_version\" => \"4.2.2\"\n  \"arviz_version\" => \"0.13.0.dev0\"\n  \"inference_library\" => \"pymc\"</code></pre>\n</details>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nidata.posterior\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nDataset with dimensions: \n  Dim{:draw} Sampled{Int64} Int64[0, 1, …, 498, 499] ForwardOrdered Irregular Points,\n  Dim{:chain} Sampled{Int64} Int64[0, 1, 2, 3] ForwardOrdered Irregular Points,\n  Dim{:school} Categorical{String} String[Choate, Deerfield, …, St. Paul's, Mt. Hermon] Unordered\nand 3 layers:\n  :mu    Float64 dims: Dim{:draw}, Dim{:chain} (500×4)\n  :theta Float64 dims: Dim{:school}, Dim{:draw}, Dim{:chain} (8×500×4)\n  :tau   Float64 dims: Dim{:draw}, Dim{:chain} (500×4)\n\nwith metadata Dict{String, Any} with 6 entries:\n  \"created_at\"                => \"2022-10-13T14:37:37.315398\"\n  \"inference_library_version\" => \"4.2.2\"\n  \"sampling_time\"             => 7.48011\n  \"tuning_steps\"              => 1000\n  \"arviz_version\"             => \"0.13.0.dev0\"\n  \"inference_library\"         => \"pymc\"\n```\n:::\n:::\n\n\nThe plotting functions we'll be using interact with a tabular view of a `Dataset`.\nLet's see what that view looks like for a `Dataset`:\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\ndf = DataFrame(idata.posterior)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n\\begin{tabular}{r|cccccc}\n\t& draw & chain & school & mu & theta & tau\\\\\n\t\\hline\n\t& Int64 & Int64 & String & Float64 & Float64 & Float64\\\\\n\t\\hline\n\t1 & 0 & 0 & Choate & 7.8718 & 12.3207 & 4.72574 \\\\\n\t2 & 1 & 0 & Choate & 3.38455 & 11.2856 & 3.90899 \\\\\n\t3 & 2 & 0 & Choate & 9.10048 & 5.70851 & 4.84403 \\\\\n\t4 & 3 & 0 & Choate & 7.30429 & 10.0373 & 1.8567 \\\\\n\t5 & 4 & 0 & Choate & 9.87968 & 9.14915 & 4.74841 \\\\\n\t6 & 5 & 0 & Choate & 7.04203 & 14.7359 & 3.51387 \\\\\n\t7 & 6 & 0 & Choate & 10.3785 & 14.304 & 4.20898 \\\\\n\t8 & 7 & 0 & Choate & 10.06 & 13.3298 & 2.6834 \\\\\n\t9 & 8 & 0 & Choate & 10.4253 & 10.4498 & 1.16889 \\\\\n\t10 & 9 & 0 & Choate & 10.8108 & 11.4731 & 1.21052 \\\\\n\t11 & 10 & 0 & Choate & 10.8529 & 9.81605 & 1.79218 \\\\\n\t12 & 11 & 0 & Choate & 11.3023 & 10.1867 & 1.83863 \\\\\n\t13 & 12 & 0 & Choate & 8.34949 & 11.034 & 4.96273 \\\\\n\t14 & 13 & 0 & Choate & 6.12774 & 7.34507 & 3.45977 \\\\\n\t15 & 14 & 0 & Choate & 8.35762 & 6.0756 & 2.33319 \\\\\n\t16 & 15 & 0 & Choate & 7.08896 & 5.06774 & 1.89091 \\\\\n\t17 & 16 & 0 & Choate & 3.43624 & 0.813843 & 1.68283 \\\\\n\t18 & 17 & 0 & Choate & 3.90795 & 2.22622 & 1.91357 \\\\\n\t19 & 18 & 0 & Choate & 3.07849 & 2.37221 & 1.59135 \\\\\n\t20 & 19 & 0 & Choate & 5.13936 & 7.0444 & 2.40805 \\\\\n\t21 & 20 & 0 & Choate & 3.24693 & 3.59892 & 2.10141 \\\\\n\t22 & 21 & 0 & Choate & 2.9384 & 2.6734 & 3.43083 \\\\\n\t23 & 22 & 0 & Choate & 5.39582 & 4.43196 & 2.17728 \\\\\n\t24 & 23 & 0 & Choate & 3.69626 & 4.32222 & 3.50028 \\\\\n\t25 & 24 & 0 & Choate & 4.165 & 4.20467 & 2.12841 \\\\\n\t26 & 25 & 0 & Choate & 7.48575 & 9.35814 & 3.09988 \\\\\n\t27 & 26 & 0 & Choate & 9.18435 & 13.1811 & 4.43473 \\\\\n\t28 & 27 & 0 & Choate & 9.35726 & 11.7953 & 2.19116 \\\\\n\t29 & 28 & 0 & Choate & 9.84417 & 12.5833 & 1.90103 \\\\\n\t30 & 29 & 0 & Choate & 3.89418 & 3.7111 & 1.30619 \\\\\n\t$\\dots$ & $\\dots$ & $\\dots$ & $\\dots$ & $\\dots$ & $\\dots$ & $\\dots$ \\\\\n\\end{tabular}\n\n:::\n:::\n\n\nThe tabular view includes dimensions and variables as columns.\n\nWhen variables with different dimensions are flattened into a tabular form, there's always some duplication of values.\nAs a simple case, note that `chain`, `draw`, and `school` all have repeated values in the above table.\n\nIn this case, `theta` has the `school` dimension, but `tau` doesn't, so the values of `tau` will be repeated in the table for each value of `school`.\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\ndf[df.school .== Ref(\"Choate\"), :].tau == df[df.school .== Ref(\"Deerfield\"), :].tau\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\ntrue\n```\n:::\n:::\n\n\nIn our first example, this will be important.\n\nHere, let's construct a trace plot.\nBesides `idata`, all functions and types in the following cell are defined in AlgebraOfGraphics or Makie:\n- `data(...)` indicates that the wrapped object implements the Tables interface\n- `mapping` indicates how the data should be used. The symbols are all column names in the table, which for us are our variable names and dimensions.\n- `visual` specifies how the data should be converted to a plot.\n- `Lines` is a plot type defined in Makie.\n- `draw` takes this combination and plots it.\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\ndraw(\n    data(idata.posterior.mu) *\n    mapping(:draw, :mu; color=:chain => nonnumeric) *\n    visual(Lines; alpha=0.8),\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n![](creating_custom_plots_files/figure-commonmark/cell-8-output-1.png){}\n:::\n:::\n\n\nNote the line `idata.posterior.mu`.\nIf we had just used `idata.posterior`, the plot would have looked more-or-less the same, but there would be artifacts due to `mu` being copied many times.\nBy selecting `mu` directly, all other dimensions are discarded, so each value of `mu` appears in the plot exactly once.\n\nWhen examining an MCMC trace plot, we want to see a \"fuzzy caterpillar\".\nInstead we see a few places where the Markov chains froze.\nWe can do the same for `theta` as well, but it's more useful here to separate these draws by `school`.\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\ndraw(\n    data(idata.posterior) *\n    mapping(:draw, :theta; layout=:school, color=:chain => nonnumeric) *\n    visual(Lines; alpha=0.8),\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n![](creating_custom_plots_files/figure-commonmark/cell-9-output-1.png){}\n:::\n:::\n\n\nSuppose we want to compare `tau` with `theta` for two different schools.\nTo do so, we use `InferenceData`s indexing syntax to subset the data.\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\ndraw(\n    data(idata[:posterior, school=At([\"Choate\", \"Deerfield\"])]) *\n    mapping(:theta, :tau; color=:school) *\n    density() *\n    visual(Contour; levels=10),\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Warning: (Dim{:school},) dims were not found in object\n└ @ DimensionalData.Dimensions ~/.julia/packages/DimensionalData/pS9IE/src/Dimensions/primitives.jl:659\n┌ Warning: (Dim{:school},) dims were not found in object\n└ @ DimensionalData.Dimensions ~/.julia/packages/DimensionalData/pS9IE/src/Dimensions/primitives.jl:659\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=10}\n![](creating_custom_plots_files/figure-commonmark/cell-10-output-2.png){}\n:::\n:::\n\n\nWe can also compare the density plots constructed from each chain for different schools.\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\ndraw(\n    data(idata.posterior) *\n    mapping(:theta; layout=:school, color=:chain => nonnumeric) *\n    density(),\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n![](creating_custom_plots_files/figure-commonmark/cell-11-output-1.png){}\n:::\n:::\n\n\nIf we want to compare many schools in a single plot, an ECDF plot is more convenient.\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\ndraw(\n    data(idata.posterior) * mapping(:theta; color=:school => nonnumeric) * visual(ECDFPlot);\n    axis=(; ylabel=\"probability\"),\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n![](creating_custom_plots_files/figure-commonmark/cell-12-output-1.png){}\n:::\n:::\n\n\nSo far we've just plotted data from one group, but we often want to combine data from multiple groups in one plot.\nThe simplest way to do this is to create the plot out of multiple layers.\nHere we use this approach to plot the observations over the posterior predictive distribution.\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\ndraw(\n    (data(idata.posterior_predictive) * mapping(:obs; layout=:school) * density()) +\n    (data(idata.observed_data) * mapping(:obs, :obs => zero => \"\"; layout=:school)),\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n![](creating_custom_plots_files/figure-commonmark/cell-13-output-1.png){}\n:::\n:::\n\n\nAnother option is to combine the groups into a single dataset.\n\nHere we compare the prior and posterior.\nSince the prior has 1 chain and the posterior has 4 chains, if we were to combine them into a table, the structure would need to be ragged.\nThis is not currently supported.\n\nWe can then either plot the two distributions separately as we did before, or we can compare a single chain from each group.\nThis is what we'll do here.\nTo concatenate the two groups, we introduce a new named dimension using `DimensionalData.Dim`.\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\ndraw(\n    data(\n        cat(\n            idata.posterior[chain=[1]], idata.prior; dims=Dim{:group}([:posterior, :prior])\n        )[:mu],\n    ) *\n    mapping(:mu; color=:group) *\n    histogram(; bins=20) *\n    visual(; alpha=0.8);\n    axis=(; ylabel=\"probability\"),\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n![](creating_custom_plots_files/figure-commonmark/cell-14-output-1.png){}\n:::\n:::\n\n\nFrom the trace plots, we suspected the geometry of this posterior was bad.\nLet's highlight divergent transitions.\nTo do so, we merge `posterior` and `samplestats`, which can do with `merge` since they share no common variable names.\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\ndraw(\n    data(merge(idata.posterior, idata.sample_stats)) * mapping(\n        :theta,\n        :tau;\n        layout=:school,\n        color=:diverging,\n        markersize=:diverging => (d -> d ? 5 : 2),\n    ),\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n![](creating_custom_plots_files/figure-commonmark/cell-15-output-1.png){}\n:::\n:::\n\n\nWhen we try building more complex plots, we may need to build new `Dataset`s from our existing ones.\n\nOne example of this is the corner plot.\nTo build this plot, we need to make a copy of `theta` with a copy of the `school` dimension.\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\ntheta = idata.posterior.theta[school=1:4]\ntheta2 = rebuild(set(theta; school=:school2); name=:theta2)\nplot_data = Dataset(theta, theta2, idata.sample_stats.diverging)\ndraw(\n    data(plot_data) * mapping(\n        :theta,\n        :theta2 => \"theta\";\n        col=:school,\n        row=:school2,\n        color=:diverging,\n        markersize=:diverging => (d -> d ? 3 : 1),\n    );\n    figure=(; figsize=(5, 5)),\n    axis=(; aspect=1),\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n![](creating_custom_plots_files/figure-commonmark/cell-16-output-1.png){}\n:::\n:::\n\n\n## Environment\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\nusing Pkg\nPkg.status()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStatus `~/work/ArviZ.jl/ArviZ.jl/docs/Project.toml`\n  [cbdf2221] AlgebraOfGraphics v0.6.16\n  [131c737c] ArviZ v0.9.0-DEV `~/work/ArviZ.jl/ArviZ.jl`\n  [13f3f980] CairoMakie v0.10.6\n  [992eb4ea] CondaPkg v0.2.18\n  [a93c6f00] DataFrames v1.5.0\n  [0703355e] DimensionalData v0.24.12\n  [31c24e10] Distributions v0.25.98\n  [e30172f5] Documenter v0.27.25\n⌅ [f6006082] EvoTrees v0.14.11\n  [7073ff75] IJulia v1.24.2\n  [c7f686f2] MCMCChains v6.0.3\n  [be115224] MCMCDiagnosticTools v0.3.4\n  [a7f614a8] MLJBase v0.21.11\n  [614be32b] MLJIteration v0.5.1\n  [438e738f] PyCall v1.96.1\n  [d330b81b] PyPlot v2.11.1\n  [754583d1] SampleChains v0.5.1\n  [c1514b29] StanSample v7.4.1\n⌅ [fce5fe82] Turing v0.24.4\n  [f43a241f] Downloads v1.6.0\n  [37e2e46d] LinearAlgebra\n  [10745b16] Statistics v1.9.0\nInfo Packages marked with ⌅ have new versions available but compatibility constraints restrict them from upgrading. To see why use `status --outdated`\n```\n:::\n:::\n\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\nversioninfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJulia Version 1.9.2\nCommit e4ee485e909 (2023-07-05 09:39 UTC)\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 2 × Intel(R) Xeon(R) Platinum 8272CL CPU @ 2.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-14.0.6 (ORCJIT, skylake-avx512)\n  Threads: 3 on 2 virtual cores\nEnvironment:\n  JULIA_CMDSTAN_HOME = /home/runner/work/ArviZ.jl/ArviZ.jl/.cmdstan//cmdstan-2.25.0/\n  JULIA_IMAGE_THREADS = 1\n  JULIA_NUM_THREADS = 2\n```\n:::\n:::\n\n\n",
    "supporting": [
      "creating_custom_plots_files"
    ],
    "filters": []
  }
}