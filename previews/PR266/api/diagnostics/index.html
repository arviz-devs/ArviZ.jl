<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Diagnostics · ArviZ.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="stable/api/diagnostics/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="ArviZ.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="ArviZ.jl logo"/></a><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../quickstart/">Quickstart</a></li><li><a class="tocitem" href="../../working_with_inference_data/">Working with <code>InferenceData</code></a></li><li><a class="tocitem" href="../../creating_custom_plots/">Creating custom plots</a></li></ul></li><li><span class="tocitem">Example Gallery</span><ul><li><a class="tocitem" href="../../mpl_examples/">Matplotlib</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../plots/">Plots</a></li><li><a class="tocitem" href="../stats/">Stats</a></li><li class="is-active"><a class="tocitem" href>Diagnostics</a><ul class="internal"><li><a class="tocitem" href="#Reference"><span>Reference</span></a></li></ul></li><li><a class="tocitem" href="../data/">Data</a></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">InferenceObjects</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../inference_data/">InferenceData</a></li><li><a class="tocitem" href="../dataset/">Dataset</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Diagnostics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Diagnostics</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/arviz-devs/ArviZ.jl/blob/main/docs/src/api/diagnostics.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="diagnostics-api"><a class="docs-heading-anchor" href="#diagnostics-api">Diagnostics</a><a id="diagnostics-api-1"></a><a class="docs-heading-anchor-permalink" href="#diagnostics-api" title="Permalink"></a></h1><ul><li><a href="#ArviZ.bfmi"><code>ArviZ.bfmi</code></a></li><li><a href="#ArviZ.ess"><code>ArviZ.ess</code></a></li><li><a href="#ArviZ.mcse"><code>ArviZ.mcse</code></a></li><li><a href="#ArviZ.rhat"><code>ArviZ.rhat</code></a></li></ul><h2 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ArviZ.bfmi" href="#ArviZ.bfmi"><code>ArviZ.bfmi</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculate the estimated Bayesian fraction of missing information (BFMI).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function is forwarded to Python&#39;s <a href="https://python.arviz.org/en/0.14.0/api/generated/arviz.bfmi.html"><code>arviz.bfmi</code></a>. The docstring of that function is included below.</p></div></div><pre><code class="nohighlight hljs">
    BFMI quantifies how well momentum resampling matches the marginal energy distribution. For more
    information on BFMI, see https://arxiv.org/pdf/1604.00695v1.pdf. The current advice is that
    values smaller than 0.3 indicate poor sampling. However, this threshold is
    provisional and may change. See
    `pystan_workflow &lt;http://mc-stan.org/users/documentation/case-studies/pystan_workflow.html&gt;`_
    for more information.

    Parameters
    ----------
    data : obj
        Any object that can be converted to an :class:`arviz.InferenceData` object.
        Refer to documentation of :func:`arviz.convert_to_dataset` for details.
        If InferenceData, energy variable needs to be found.

    Returns
    -------
    z : array
        The Bayesian fraction of missing information of the model and trace. One element per
        chain in the trace.

    See Also
    --------
    plot_energy : Plot energy transition distribution and marginal energy
                  distribution in HMC algorithms.

    Examples
    --------
    Compute the BFMI of an InferenceData object

    .. ipython::

        In [1]: import arviz as az
           ...: data = az.load_arviz_data(&#39;radon&#39;)
           ...: az.bfmi(data)

    </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arviz-devs/ArviZ.jl/blob/d944f83c478eb71d8b4dd5faf0e2ff8df7905bd5/src/diagnostics.jl#L1-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArviZ.ess" href="#ArviZ.ess"><code>ArviZ.ess</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ess(data; kwargs...) -&gt; Dataset</code></pre><p>Estimate the effective sample size (ESS).</p><p>The basic ESS (<span>$N_{\mathit{eff}}$</span>) diagnostic is computed by<sup class="footnote-reference"><a id="citeref-Vehtari2019" href="#footnote-Vehtari2019">[Vehtari2019]</a></sup><sup class="footnote-reference"><a id="citeref-BDA3_ESS" href="#footnote-BDA3_ESS">[BDA3_ESS]</a></sup>:</p><p class="math-container">\[\hat{N}_{\mathit{eff}} = \frac{MN}{\hat{\tau}}\\
\hat{\tau} = -1 + 2 \sum_{t&#39;=0}^K \hat{P}_{t&#39;},\]</p><p>where <span>$M$</span> is the number of chains, <span>$N$</span> the number of draws, <span>$\hat{\rho}_t$</span> is the estimated autocorrelation at lag <span>$t$</span>, and <span>$K$</span> is the largest integer for which <span>$\hat{P}_{K} = \hat{\rho}_{2K} + \hat{\rho}_{2K+1}$</span> is still positive.</p><p>The current implementation is similar to Stan&#39;s, which uses Geyer&#39;s initial monotone sequence criterion<sup class="footnote-reference"><a id="citeref-StanManual_ESS" href="#footnote-StanManual_ESS">[StanManual_ESS]</a></sup>.</p><p>See also: <a href="#ArviZ.rhat"><code>rhat</code></a>, <a href="#ArviZ.mcse"><code>mcse</code></a>, <a href="../plots/#ArviZ.plot_ess"><code>plot_ess</code></a>,  <a href="../stats/#StatsBase.summarystats"><code>summarystats</code></a></p><p><strong>Arguments</strong></p><ul><li><code>data::Any</code>: Any object that can be converted to an <a href="../inference_data/#InferenceObjects.InferenceData"><code>InferenceData</code></a> object. See   <a href="../inference_data/#InferenceObjects.convert_to_inference_data"><code>convert_to_inference_data</code></a> for details.</li></ul><p><strong>Keywords</strong></p><ul><li><code>var_names</code>: <code>Symbol</code> names of variables to include in the returned <code>Dataset</code>. Defaults to   all.</li><li><code>method::Symbol=:bulk</code>: ESS method to use. Valid options are:<ul><li><code>:bulk</code></li><li><code>:tail</code> (specify <code>prob</code>)</li><li><code>:quantile</code> (specify <code>prob</code>)</li><li><code>:mean</code>: old ESS</li><li><code>:sd</code></li><li><code>:median</code></li><li><code>:mad</code>: mean absolute deviance</li><li><code>:z_scale</code></li><li><code>:folded</code></li><li><code>:identity</code></li><li><code>:local</code> (specify <code>prob</code>)</li></ul></li><li><code>prob::Union{Real,NTuple{2,Real}}</code>: Probability for <code>:tail</code>, <code>:quantile</code>, or <code>:local</code> ESS   <code>method</code>.</li></ul><p><strong>Examples</strong></p><p>Calculate the ESS using the default arguments:</p><pre><code class="language-julia-repl hljs">julia&gt; using ArviZ

julia&gt; data = load_example_data(&quot;non_centered_eight&quot;);

julia&gt; ess(data)
Dataset with dimensions:
  Dim{:school} Categorical{String} String[Choate, Deerfield, …, St. Paul&#39;s, Mt. Hermon] Unordered
and 4 layers:
  :mu      Float64 dims:
  :theta_t Float64 dims: Dim{:school} (8)
  :theta   Float64 dims: Dim{:school} (8)
  :tau     Float64 dims:</code></pre><p>Calculate the ESS using the <code>:tail</code> method, leaving the <code>prob</code> argument at its default value:</p><pre><code class="language-julia-repl hljs">julia&gt; ess(data; method=:tail)
Dataset with dimensions:
  Dim{:school} Categorical{String} String[Choate, Deerfield, …, St. Paul&#39;s, Mt. Hermon] Unordered
and 4 layers:
  :mu      Float64 dims:
  :theta_t Float64 dims: Dim{:school} (8)
  :theta   Float64 dims: Dim{:school} (8)
  :tau     Float64 dims:</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arviz-devs/ArviZ.jl/blob/d944f83c478eb71d8b4dd5faf0e2ff8df7905bd5/src/diagnostics.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArviZ.mcse" href="#ArviZ.mcse"><code>ArviZ.mcse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mcse(data; kwargs...) -&gt; Dataset</code></pre><p>Calculate the Markov Chain Standard Error statistic.</p><p>See also: <a href="#ArviZ.ess"><code>ess</code></a>, <a href="../plots/#ArviZ.plot_mcse"><code>plot_mcse</code></a>, <a href="../stats/#StatsBase.summarystats"><code>summarystats</code></a></p><p><strong>Arguments</strong></p><ul><li><code>data::Any</code>: Any object that can be converted to an <a href="../inference_data/#InferenceObjects.InferenceData"><code>InferenceData</code></a> object. See <a href="../inference_data/#InferenceObjects.convert_to_inference_data"><code>convert_to_inference_data</code></a> for details.</li></ul><p><strong>Keywords</strong></p><ul><li><p><code>var_names</code>: <code>Symbol</code> names of variables to include in the returned <code>Dataset</code>. Defaults to all.</p></li><li><p><code>method::Symbol=:bulk</code>: ESS method to use. Valid options are:</p><ul><li><code>:mean</code>:</li><li><code>:sd</code></li><li><code>:median</code></li><li><code>:quantile</code> (specify <code>prob</code>)</li></ul></li><li><p><code>prob::Real</code>: Probability for <code>:quantile</code> ESS <code>method</code>.</p></li></ul><p><strong>Examples</strong></p><p>Calculate the MCSE using the default arguments:</p><pre><code class="language-julia-repl hljs">julia&gt; using ArviZ

julia&gt; data = load_example_data(&quot;non_centered_eight&quot;);

julia&gt; mcse(data)
Dataset with dimensions:
  Dim{:school} Categorical{String} String[Choate, Deerfield, …, St. Paul&#39;s, Mt. Hermon] Unordered
and 4 layers:
  :mu      Float64 dims:
  :theta_t Float64 dims: Dim{:school} (8)
  :theta   Float64 dims: Dim{:school} (8)
  :tau     Float64 dims:</code></pre><p>Calculate the MCSE using the <code>:quantile</code> method:</p><pre><code class="language-julia-repl hljs">julia&gt; mcse(data; method=:quantile, prob=0.7)
Dataset with dimensions:
  Dim{:school} Categorical{String} String[Choate, Deerfield, …, St. Paul&#39;s, Mt. Hermon] Unordered
and 4 layers:
  :mu      Float64 dims:
  :theta_t Float64 dims: Dim{:school} (8)
  :theta   Float64 dims: Dim{:school} (8)
  :tau     Float64 dims:</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arviz-devs/ArviZ.jl/blob/d944f83c478eb71d8b4dd5faf0e2ff8df7905bd5/src/diagnostics.jl#L97-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArviZ.rhat" href="#ArviZ.rhat"><code>ArviZ.rhat</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Compute estimate of rank normalized splitR-hat for a set of traces.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function is forwarded to Python&#39;s <a href="https://python.arviz.org/en/0.14.0/api/generated/arviz.rhat.html"><code>arviz.rhat</code></a>. The docstring of that function is included below.</p></div></div><pre><code class="nohighlight hljs">
    The rank normalized R-hat diagnostic tests for lack of convergence by comparing the variance
    between multiple chains to the variance within each chain. If convergence has been achieved,
    the between-chain and within-chain variances should be identical. To be most effective in
    detecting evidence for nonconvergence, each chain should have been initialized to starting
    values that are dispersed relative to the target distribution.

    Parameters
    ----------
    data : obj
        Any object that can be converted to an :class:`arviz.InferenceData` object.
        Refer to documentation of :func:`arviz.convert_to_dataset` for details.
        At least 2 posterior chains are needed to compute this diagnostic of one or more
        stochastic parameters.
        For ndarray: shape = (chain, draw).
        For n-dimensional ndarray transform first to dataset with ``az.convert_to_dataset``.
    var_names : list
        Names of variables to include in the rhat report
    method : str
        Select R-hat method. Valid methods are:
        - &quot;rank&quot;        # recommended by Vehtari et al. (2019)
        - &quot;split&quot;
        - &quot;folded&quot;
        - &quot;z_scale&quot;
        - &quot;identity&quot;
    dask_kwargs : dict, optional
        Dask related kwargs passed to :func:`~arviz.wrap_xarray_ufunc`.

    Returns
    -------
    xarray.Dataset
      Returns dataset of the potential scale reduction factors, :math:`\hat{R}`

    See Also
    --------
    ess : Calculate estimate of the effective sample size (ess).
    mcse : Calculate Markov Chain Standard Error statistic.
    plot_forest : Forest plot to compare HDI intervals from a number of distributions.

    Notes
    -----
    The diagnostic is computed by:

      .. math:: \hat{R} = \frac{\hat{V}}{W}

    where :math:`W` is the within-chain variance and :math:`\hat{V}` is the posterior variance
    estimate for the pooled rank-traces. This is the potential scale reduction factor, which
    converges to unity when each of the traces is a sample from the target posterior. Values
    greater than one indicate that one or more chains have not yet converged.

    Rank values are calculated over all the chains with ``scipy.stats.rankdata``.
    Each chain is split in two and normalized with the z-transform following Vehtari et al. (2019).

    References
    ----------
    * Vehtari et al. (2019) see https://arxiv.org/abs/1903.08008
    * Gelman et al. BDA (2014)
    * Brooks and Gelman (1998)
    * Gelman and Rubin (1992)

    Examples
    --------
    Calculate the R-hat using the default arguments:

    .. ipython::

        In [1]: import arviz as az
           ...: data = az.load_arviz_data(&quot;non_centered_eight&quot;)
           ...: az.rhat(data)

    Calculate the R-hat of some variables using the folded method:

    .. ipython::

        In [1]: az.rhat(data, var_names=[&quot;mu&quot;, &quot;theta_t&quot;], method=&quot;folded&quot;)

    </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/arviz-devs/ArviZ.jl/blob/d944f83c478eb71d8b4dd5faf0e2ff8df7905bd5/src/diagnostics.jl#L4-L90">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Vehtari2019"><a class="tag is-link" href="#citeref-Vehtari2019">Vehtari2019</a>Rank-normalization, folding, and localization: An improved <span>$\hat{R}$</span> for assessing convergence of MCMC. 2019. <a href="https://arxiv.org/abs/1903.08008">arXiv:1903.08008</a>[stat.CO]</li><li class="footnote" id="footnote-StanManual_ESS"><a class="tag is-link" href="#citeref-StanManual_ESS">StanManual_ESS</a>https://mc-stan.org/docs/2_18/reference-manual/effective-sample-size-section.html. Section 15.4.2</li><li class="footnote" id="footnote-BDA3_ESS"><a class="tag is-link" href="#citeref-BDA3_ESS">BDA3_ESS</a>Gelman et al. Bayesian Data Analysis (2014). <a href="http://www.stat.columbia.edu/~gelman/book/BDA3.pdf">PDF</a>. Section 11.5</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../stats/">« Stats</a><a class="docs-footer-nextpage" href="../data/">Data »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 1 March 2023 02:23">Wednesday 1 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
